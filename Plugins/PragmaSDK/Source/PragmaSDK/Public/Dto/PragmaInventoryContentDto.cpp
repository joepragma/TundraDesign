// <auto-generated>
//      Generated by Pragma Platform protoc-custom-plugins sdk-unreal4 target.  DO NOT EDIT!
//      Source template: unreal4/Dto.cpp.mustache
// </auto-generated>

#include "PragmaInventoryContentDto.h"
#include "CoreMinimal.h"
#include "PragmaJson.h"



bool operator==(const FPragma_Inventory_SteamApp& Lhs, const FPragma_Inventory_SteamApp& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.AppId == Rhs.AppId
;
}
bool operator!=(const FPragma_Inventory_SteamApp& Lhs, const FPragma_Inventory_SteamApp& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_SteamInventoryItem& Lhs, const FPragma_Inventory_SteamInventoryItem& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.ItemDefId == Rhs.ItemDefId
;
}
bool operator!=(const FPragma_Inventory_SteamInventoryItem& Lhs, const FPragma_Inventory_SteamInventoryItem& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_TwitchDrop& Lhs, const FPragma_Inventory_TwitchDrop& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.RewardId == Rhs.RewardId
;
}
bool operator!=(const FPragma_Inventory_TwitchDrop& Lhs, const FPragma_Inventory_TwitchDrop& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_EpicEntitlement& Lhs, const FPragma_Inventory_EpicEntitlement& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.AudienceItemId == Rhs.AudienceItemId
			&& Lhs.OfferType == Rhs.OfferType
;
}
bool operator!=(const FPragma_Inventory_EpicEntitlement& Lhs, const FPragma_Inventory_EpicEntitlement& Rhs)
{
	return !(Lhs == Rhs);
}

FPragma_Inventory_SteamEntitlement_Source::FPragma_Inventory_SteamEntitlement_Source() {}
FPragma_Inventory_SteamEntitlement_Source::~FPragma_Inventory_SteamEntitlement_Source()
{
	Reset();
}

FPragma_Inventory_SteamEntitlement_Source::FPragma_Inventory_SteamEntitlement_Source(const FPragma_Inventory_SteamEntitlement_Source& Other)
{
	*this = Other;
}

bool FPragma_Inventory_SteamEntitlement_Source::Equals(const FPragma_Inventory_SteamEntitlement_Source& Other) const
{
    if (OneOfType() != Other.OneOfType())
    {
        return false;
    }
	switch (OneOfType())
	{
	case EPragma_Inventory_SteamEntitlement_SourceType::InventoryItem:
		return InventoryItem() == Other.InventoryItem();
	case EPragma_Inventory_SteamEntitlement_SourceType::App:
		return App() == Other.App();
	case EPragma_Inventory_SteamEntitlement_SourceType::Invalid:
        return true;
	default:
		return false;
	}
}

FPragma_Inventory_SteamEntitlement_Source& FPragma_Inventory_SteamEntitlement_Source::operator=(const FPragma_Inventory_SteamEntitlement_Source& Other)
{
	Reset();
	Type = Other.OneOfType();
	switch (Other.OneOfType())
	{
	case EPragma_Inventory_SteamEntitlement_SourceType::InventoryItem:
		new(Union.InventoryItem.GetTypedPtr()) FPragma_Inventory_SteamInventoryItem(Other.InventoryItem());
		break;
	case EPragma_Inventory_SteamEntitlement_SourceType::App:
		new(Union.App.GetTypedPtr()) FPragma_Inventory_SteamApp(Other.App());
		break;
	case EPragma_Inventory_SteamEntitlement_SourceType::Invalid:
	default:
		break;
	}
	return *this;
}

void FPragma_Inventory_SteamEntitlement_Source::Reset()
{
	switch (OneOfType())
	{
	case EPragma_Inventory_SteamEntitlement_SourceType::InventoryItem:
		Union.InventoryItem.GetTypedPtr()->~FPragma_Inventory_SteamInventoryItem();
		break;
	case EPragma_Inventory_SteamEntitlement_SourceType::App:
		Union.App.GetTypedPtr()->~FPragma_Inventory_SteamApp();
		break;
	case EPragma_Inventory_SteamEntitlement_SourceType::Invalid:
	default:
		break;
	}
	Type = EPragma_Inventory_SteamEntitlement_SourceType::Invalid;
}

const FPragma_Inventory_SteamInventoryItem& FPragma_Inventory_SteamEntitlement_Source::InventoryItem() const {
	checkf(OneOfType() == EPragma_Inventory_SteamEntitlement_SourceType::InventoryItem, TEXT("Failed to retrieve InventoryItem from FPragma_Inventory_SteamEntitlement_Source. Check the OneOfType() before accessing the value."));
	return *Union.InventoryItem.GetTypedPtr();
}
const FPragma_Inventory_SteamApp& FPragma_Inventory_SteamEntitlement_Source::App() const {
	checkf(OneOfType() == EPragma_Inventory_SteamEntitlement_SourceType::App, TEXT("Failed to retrieve App from FPragma_Inventory_SteamEntitlement_Source. Check the OneOfType() before accessing the value."));
	return *Union.App.GetTypedPtr();
}

void FPragma_Inventory_SteamEntitlement_Source::SetInventoryItem(const FPragma_Inventory_SteamInventoryItem& Value)
{
	Reset();
	Type = EPragma_Inventory_SteamEntitlement_SourceType::InventoryItem;
	new(Union.InventoryItem.GetTypedPtr()) FPragma_Inventory_SteamInventoryItem(Value);
}
void FPragma_Inventory_SteamEntitlement_Source::SetApp(const FPragma_Inventory_SteamApp& Value)
{
	Reset();
	Type = EPragma_Inventory_SteamEntitlement_SourceType::App;
	new(Union.App.GetTypedPtr()) FPragma_Inventory_SteamApp(Value);
}

bool FPragma_Inventory_SteamEntitlement_Source::SerializeIntoParentJson(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	const FPragma_Inventory_SteamEntitlement_Source& OneOf = static_cast<const FPragma_Inventory_SteamEntitlement*>(Value)->Source;
	switch (OneOf.OneOfType())
	{
		case EPragma_Inventory_SteamEntitlement_SourceType::InventoryItem:
			OutJsonObj->SetField("inventoryItem", PragmaJson::StructToJsonValue(*OneOf.Union.InventoryItem.GetTypedPtr()));
			break;
		case EPragma_Inventory_SteamEntitlement_SourceType::App:
			OutJsonObj->SetField("app", PragmaJson::StructToJsonValue(*OneOf.Union.App.GetTypedPtr()));
			break;
		default:
			break;
	}
	// Per protobuf spec, it's ok to have empty oneof.
	return true;
}
bool FPragma_Inventory_SteamEntitlement_Source::DeserializeFromParentJson(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	FPragma_Inventory_SteamEntitlement_Source& OutOneOf = static_cast<FPragma_Inventory_SteamEntitlement*>(OutValue)->Source;
	if (JsonObj->HasField("inventoryItem"))
	{
		OutOneOf.Type = EPragma_Inventory_SteamEntitlement_SourceType::InventoryItem;
		new(OutOneOf.Union.InventoryItem.GetTypedPtr()) FPragma_Inventory_SteamInventoryItem(PragmaJson::JsonValueToStruct<FPragma_Inventory_SteamInventoryItem>(JsonObj->TryGetField(TEXT("inventoryItem")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	if (JsonObj->HasField("app"))
	{
		OutOneOf.Type = EPragma_Inventory_SteamEntitlement_SourceType::App;
		new(OutOneOf.Union.App.GetTypedPtr()) FPragma_Inventory_SteamApp(PragmaJson::JsonValueToStruct<FPragma_Inventory_SteamApp>(JsonObj->TryGetField(TEXT("app")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	// Per protobuf spec, oneofs have _at most_ one of the fields. None set is valid, so we always return true.
	return true;
}

bool operator==(const FPragma_Inventory_SteamEntitlement_Source& Lhs, const FPragma_Inventory_SteamEntitlement_Source& Rhs)
{
	return Lhs.Equals(Rhs);
}
bool operator!=(const FPragma_Inventory_SteamEntitlement_Source& Lhs, const FPragma_Inventory_SteamEntitlement_Source& Rhs)
{
	return !(Lhs == Rhs);
}


bool FPragma_Inventory_SteamEntitlement::AddonSerializer(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	bool Success = true;
	Success &= FPragma_Inventory_SteamEntitlement_Source::SerializeIntoParentJson(Value, OutJsonObj);
	return Success;
}

bool FPragma_Inventory_SteamEntitlement::AddonDeserializer(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	bool Success = true;
	Success &= FPragma_Inventory_SteamEntitlement_Source::DeserializeFromParentJson(JsonObj, OutValue);
	return Success;
}

bool operator==(const FPragma_Inventory_SteamEntitlement& Lhs, const FPragma_Inventory_SteamEntitlement& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.Source == Rhs.Source
;
}
bool operator!=(const FPragma_Inventory_SteamEntitlement& Lhs, const FPragma_Inventory_SteamEntitlement& Rhs)
{
	return !(Lhs == Rhs);
}

FPragma_Inventory_ProviderDetails_Data::FPragma_Inventory_ProviderDetails_Data() {}
FPragma_Inventory_ProviderDetails_Data::~FPragma_Inventory_ProviderDetails_Data()
{
	Reset();
}

FPragma_Inventory_ProviderDetails_Data::FPragma_Inventory_ProviderDetails_Data(const FPragma_Inventory_ProviderDetails_Data& Other)
{
	*this = Other;
}

bool FPragma_Inventory_ProviderDetails_Data::Equals(const FPragma_Inventory_ProviderDetails_Data& Other) const
{
    if (OneOfType() != Other.OneOfType())
    {
        return false;
    }
	switch (OneOfType())
	{
	case EPragma_Inventory_ProviderDetails_DataType::Ext:
		return Ext() == Other.Ext();
	case EPragma_Inventory_ProviderDetails_DataType::SteamEntitlement:
		return SteamEntitlement() == Other.SteamEntitlement();
	case EPragma_Inventory_ProviderDetails_DataType::EpicEntitlement:
		return EpicEntitlement() == Other.EpicEntitlement();
	case EPragma_Inventory_ProviderDetails_DataType::TwitchDrop:
		return TwitchDrop() == Other.TwitchDrop();
	case EPragma_Inventory_ProviderDetails_DataType::Invalid:
        return true;
	default:
		return false;
	}
}

FPragma_Inventory_ProviderDetails_Data& FPragma_Inventory_ProviderDetails_Data::operator=(const FPragma_Inventory_ProviderDetails_Data& Other)
{
	Reset();
	Type = Other.OneOfType();
	switch (Other.OneOfType())
	{
	case EPragma_Inventory_ProviderDetails_DataType::Ext:
		new(Union.Ext.GetTypedPtr()) FPragma_Inventory_ExtEntitlement(Other.Ext());
		break;
	case EPragma_Inventory_ProviderDetails_DataType::SteamEntitlement:
		new(Union.SteamEntitlement.GetTypedPtr()) FPragma_Inventory_SteamEntitlement(Other.SteamEntitlement());
		break;
	case EPragma_Inventory_ProviderDetails_DataType::EpicEntitlement:
		new(Union.EpicEntitlement.GetTypedPtr()) FPragma_Inventory_EpicEntitlement(Other.EpicEntitlement());
		break;
	case EPragma_Inventory_ProviderDetails_DataType::TwitchDrop:
		new(Union.TwitchDrop.GetTypedPtr()) FPragma_Inventory_TwitchDrop(Other.TwitchDrop());
		break;
	case EPragma_Inventory_ProviderDetails_DataType::Invalid:
	default:
		break;
	}
	return *this;
}

void FPragma_Inventory_ProviderDetails_Data::Reset()
{
	switch (OneOfType())
	{
	case EPragma_Inventory_ProviderDetails_DataType::Ext:
		Union.Ext.GetTypedPtr()->~FPragma_Inventory_ExtEntitlement();
		break;
	case EPragma_Inventory_ProviderDetails_DataType::SteamEntitlement:
		Union.SteamEntitlement.GetTypedPtr()->~FPragma_Inventory_SteamEntitlement();
		break;
	case EPragma_Inventory_ProviderDetails_DataType::EpicEntitlement:
		Union.EpicEntitlement.GetTypedPtr()->~FPragma_Inventory_EpicEntitlement();
		break;
	case EPragma_Inventory_ProviderDetails_DataType::TwitchDrop:
		Union.TwitchDrop.GetTypedPtr()->~FPragma_Inventory_TwitchDrop();
		break;
	case EPragma_Inventory_ProviderDetails_DataType::Invalid:
	default:
		break;
	}
	Type = EPragma_Inventory_ProviderDetails_DataType::Invalid;
}

const FPragma_Inventory_ExtEntitlement& FPragma_Inventory_ProviderDetails_Data::Ext() const {
	checkf(OneOfType() == EPragma_Inventory_ProviderDetails_DataType::Ext, TEXT("Failed to retrieve Ext from FPragma_Inventory_ProviderDetails_Data. Check the OneOfType() before accessing the value."));
	return *Union.Ext.GetTypedPtr();
}
const FPragma_Inventory_SteamEntitlement& FPragma_Inventory_ProviderDetails_Data::SteamEntitlement() const {
	checkf(OneOfType() == EPragma_Inventory_ProviderDetails_DataType::SteamEntitlement, TEXT("Failed to retrieve SteamEntitlement from FPragma_Inventory_ProviderDetails_Data. Check the OneOfType() before accessing the value."));
	return *Union.SteamEntitlement.GetTypedPtr();
}
const FPragma_Inventory_EpicEntitlement& FPragma_Inventory_ProviderDetails_Data::EpicEntitlement() const {
	checkf(OneOfType() == EPragma_Inventory_ProviderDetails_DataType::EpicEntitlement, TEXT("Failed to retrieve EpicEntitlement from FPragma_Inventory_ProviderDetails_Data. Check the OneOfType() before accessing the value."));
	return *Union.EpicEntitlement.GetTypedPtr();
}
const FPragma_Inventory_TwitchDrop& FPragma_Inventory_ProviderDetails_Data::TwitchDrop() const {
	checkf(OneOfType() == EPragma_Inventory_ProviderDetails_DataType::TwitchDrop, TEXT("Failed to retrieve TwitchDrop from FPragma_Inventory_ProviderDetails_Data. Check the OneOfType() before accessing the value."));
	return *Union.TwitchDrop.GetTypedPtr();
}

void FPragma_Inventory_ProviderDetails_Data::SetExt(const FPragma_Inventory_ExtEntitlement& Value)
{
	Reset();
	Type = EPragma_Inventory_ProviderDetails_DataType::Ext;
	new(Union.Ext.GetTypedPtr()) FPragma_Inventory_ExtEntitlement(Value);
}
void FPragma_Inventory_ProviderDetails_Data::SetSteamEntitlement(const FPragma_Inventory_SteamEntitlement& Value)
{
	Reset();
	Type = EPragma_Inventory_ProviderDetails_DataType::SteamEntitlement;
	new(Union.SteamEntitlement.GetTypedPtr()) FPragma_Inventory_SteamEntitlement(Value);
}
void FPragma_Inventory_ProviderDetails_Data::SetEpicEntitlement(const FPragma_Inventory_EpicEntitlement& Value)
{
	Reset();
	Type = EPragma_Inventory_ProviderDetails_DataType::EpicEntitlement;
	new(Union.EpicEntitlement.GetTypedPtr()) FPragma_Inventory_EpicEntitlement(Value);
}
void FPragma_Inventory_ProviderDetails_Data::SetTwitchDrop(const FPragma_Inventory_TwitchDrop& Value)
{
	Reset();
	Type = EPragma_Inventory_ProviderDetails_DataType::TwitchDrop;
	new(Union.TwitchDrop.GetTypedPtr()) FPragma_Inventory_TwitchDrop(Value);
}

bool FPragma_Inventory_ProviderDetails_Data::SerializeIntoParentJson(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	const FPragma_Inventory_ProviderDetails_Data& OneOf = static_cast<const FPragma_Inventory_ProviderDetails*>(Value)->Data;
	switch (OneOf.OneOfType())
	{
		case EPragma_Inventory_ProviderDetails_DataType::Ext:
			OutJsonObj->SetField("ext", PragmaJson::StructToJsonValue(*OneOf.Union.Ext.GetTypedPtr()));
			break;
		case EPragma_Inventory_ProviderDetails_DataType::SteamEntitlement:
			OutJsonObj->SetField("steamEntitlement", PragmaJson::StructToJsonValue(*OneOf.Union.SteamEntitlement.GetTypedPtr()));
			break;
		case EPragma_Inventory_ProviderDetails_DataType::EpicEntitlement:
			OutJsonObj->SetField("epicEntitlement", PragmaJson::StructToJsonValue(*OneOf.Union.EpicEntitlement.GetTypedPtr()));
			break;
		case EPragma_Inventory_ProviderDetails_DataType::TwitchDrop:
			OutJsonObj->SetField("twitchDrop", PragmaJson::StructToJsonValue(*OneOf.Union.TwitchDrop.GetTypedPtr()));
			break;
		default:
			break;
	}
	// Per protobuf spec, it's ok to have empty oneof.
	return true;
}
bool FPragma_Inventory_ProviderDetails_Data::DeserializeFromParentJson(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	FPragma_Inventory_ProviderDetails_Data& OutOneOf = static_cast<FPragma_Inventory_ProviderDetails*>(OutValue)->Data;
	if (JsonObj->HasField("ext"))
	{
		OutOneOf.Type = EPragma_Inventory_ProviderDetails_DataType::Ext;
		new(OutOneOf.Union.Ext.GetTypedPtr()) FPragma_Inventory_ExtEntitlement(PragmaJson::JsonValueToStruct<FPragma_Inventory_ExtEntitlement>(JsonObj->TryGetField(TEXT("ext")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	if (JsonObj->HasField("steamEntitlement"))
	{
		OutOneOf.Type = EPragma_Inventory_ProviderDetails_DataType::SteamEntitlement;
		new(OutOneOf.Union.SteamEntitlement.GetTypedPtr()) FPragma_Inventory_SteamEntitlement(PragmaJson::JsonValueToStruct<FPragma_Inventory_SteamEntitlement>(JsonObj->TryGetField(TEXT("steamEntitlement")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	if (JsonObj->HasField("epicEntitlement"))
	{
		OutOneOf.Type = EPragma_Inventory_ProviderDetails_DataType::EpicEntitlement;
		new(OutOneOf.Union.EpicEntitlement.GetTypedPtr()) FPragma_Inventory_EpicEntitlement(PragmaJson::JsonValueToStruct<FPragma_Inventory_EpicEntitlement>(JsonObj->TryGetField(TEXT("epicEntitlement")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	if (JsonObj->HasField("twitchDrop"))
	{
		OutOneOf.Type = EPragma_Inventory_ProviderDetails_DataType::TwitchDrop;
		new(OutOneOf.Union.TwitchDrop.GetTypedPtr()) FPragma_Inventory_TwitchDrop(PragmaJson::JsonValueToStruct<FPragma_Inventory_TwitchDrop>(JsonObj->TryGetField(TEXT("twitchDrop")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	// Per protobuf spec, oneofs have _at most_ one of the fields. None set is valid, so we always return true.
	return true;
}

bool operator==(const FPragma_Inventory_ProviderDetails_Data& Lhs, const FPragma_Inventory_ProviderDetails_Data& Rhs)
{
	return Lhs.Equals(Rhs);
}
bool operator!=(const FPragma_Inventory_ProviderDetails_Data& Lhs, const FPragma_Inventory_ProviderDetails_Data& Rhs)
{
	return !(Lhs == Rhs);
}


bool FPragma_Inventory_ProviderDetails::AddonSerializer(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	bool Success = true;
	Success &= FPragma_Inventory_ProviderDetails_Data::SerializeIntoParentJson(Value, OutJsonObj);
	return Success;
}

bool FPragma_Inventory_ProviderDetails::AddonDeserializer(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	bool Success = true;
	Success &= FPragma_Inventory_ProviderDetails_Data::DeserializeFromParentJson(JsonObj, OutValue);
	return Success;
}

bool operator==(const FPragma_Inventory_ProviderDetails& Lhs, const FPragma_Inventory_ProviderDetails& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.Data == Rhs.Data
;
}
bool operator!=(const FPragma_Inventory_ProviderDetails& Lhs, const FPragma_Inventory_ProviderDetails& Rhs)
{
	return !(Lhs == Rhs);
}

FPragma_Inventory_ProviderEntitlement_Grant::FPragma_Inventory_ProviderEntitlement_Grant() {}
FPragma_Inventory_ProviderEntitlement_Grant::~FPragma_Inventory_ProviderEntitlement_Grant()
{
	Reset();
}

FPragma_Inventory_ProviderEntitlement_Grant::FPragma_Inventory_ProviderEntitlement_Grant(const FPragma_Inventory_ProviderEntitlement_Grant& Other)
{
	*this = Other;
}

bool FPragma_Inventory_ProviderEntitlement_Grant::Equals(const FPragma_Inventory_ProviderEntitlement_Grant& Other) const
{
    if (OneOfType() != Other.OneOfType())
    {
        return false;
    }
	switch (OneOfType())
	{
	case EPragma_Inventory_ProviderEntitlement_GrantType::Instanced:
		return Instanced() == Other.Instanced();
	case EPragma_Inventory_ProviderEntitlement_GrantType::Stackable:
		return Stackable() == Other.Stackable();
	case EPragma_Inventory_ProviderEntitlement_GrantType::Bundle:
		return Bundle() == Other.Bundle();
	case EPragma_Inventory_ProviderEntitlement_GrantType::Invalid:
        return true;
	default:
		return false;
	}
}

FPragma_Inventory_ProviderEntitlement_Grant& FPragma_Inventory_ProviderEntitlement_Grant::operator=(const FPragma_Inventory_ProviderEntitlement_Grant& Other)
{
	Reset();
	Type = Other.OneOfType();
	switch (Other.OneOfType())
	{
	case EPragma_Inventory_ProviderEntitlement_GrantType::Instanced:
		new(Union.Instanced.GetTypedPtr()) FPragma_Inventory_InstancedItemServerGrant(Other.Instanced());
		break;
	case EPragma_Inventory_ProviderEntitlement_GrantType::Stackable:
		new(Union.Stackable.GetTypedPtr()) FPragma_Inventory_StackableItemGrant(Other.Stackable());
		break;
	case EPragma_Inventory_ProviderEntitlement_GrantType::Bundle:
		new(Union.Bundle.GetTypedPtr()) FPragma_Inventory_ItemBundleGrant(Other.Bundle());
		break;
	case EPragma_Inventory_ProviderEntitlement_GrantType::Invalid:
	default:
		break;
	}
	return *this;
}

void FPragma_Inventory_ProviderEntitlement_Grant::Reset()
{
	switch (OneOfType())
	{
	case EPragma_Inventory_ProviderEntitlement_GrantType::Instanced:
		Union.Instanced.GetTypedPtr()->~FPragma_Inventory_InstancedItemServerGrant();
		break;
	case EPragma_Inventory_ProviderEntitlement_GrantType::Stackable:
		Union.Stackable.GetTypedPtr()->~FPragma_Inventory_StackableItemGrant();
		break;
	case EPragma_Inventory_ProviderEntitlement_GrantType::Bundle:
		Union.Bundle.GetTypedPtr()->~FPragma_Inventory_ItemBundleGrant();
		break;
	case EPragma_Inventory_ProviderEntitlement_GrantType::Invalid:
	default:
		break;
	}
	Type = EPragma_Inventory_ProviderEntitlement_GrantType::Invalid;
}

const FPragma_Inventory_InstancedItemServerGrant& FPragma_Inventory_ProviderEntitlement_Grant::Instanced() const {
	checkf(OneOfType() == EPragma_Inventory_ProviderEntitlement_GrantType::Instanced, TEXT("Failed to retrieve Instanced from FPragma_Inventory_ProviderEntitlement_Grant. Check the OneOfType() before accessing the value."));
	return *Union.Instanced.GetTypedPtr();
}
const FPragma_Inventory_StackableItemGrant& FPragma_Inventory_ProviderEntitlement_Grant::Stackable() const {
	checkf(OneOfType() == EPragma_Inventory_ProviderEntitlement_GrantType::Stackable, TEXT("Failed to retrieve Stackable from FPragma_Inventory_ProviderEntitlement_Grant. Check the OneOfType() before accessing the value."));
	return *Union.Stackable.GetTypedPtr();
}
const FPragma_Inventory_ItemBundleGrant& FPragma_Inventory_ProviderEntitlement_Grant::Bundle() const {
	checkf(OneOfType() == EPragma_Inventory_ProviderEntitlement_GrantType::Bundle, TEXT("Failed to retrieve Bundle from FPragma_Inventory_ProviderEntitlement_Grant. Check the OneOfType() before accessing the value."));
	return *Union.Bundle.GetTypedPtr();
}

void FPragma_Inventory_ProviderEntitlement_Grant::SetInstanced(const FPragma_Inventory_InstancedItemServerGrant& Value)
{
	Reset();
	Type = EPragma_Inventory_ProviderEntitlement_GrantType::Instanced;
	new(Union.Instanced.GetTypedPtr()) FPragma_Inventory_InstancedItemServerGrant(Value);
}
void FPragma_Inventory_ProviderEntitlement_Grant::SetStackable(const FPragma_Inventory_StackableItemGrant& Value)
{
	Reset();
	Type = EPragma_Inventory_ProviderEntitlement_GrantType::Stackable;
	new(Union.Stackable.GetTypedPtr()) FPragma_Inventory_StackableItemGrant(Value);
}
void FPragma_Inventory_ProviderEntitlement_Grant::SetBundle(const FPragma_Inventory_ItemBundleGrant& Value)
{
	Reset();
	Type = EPragma_Inventory_ProviderEntitlement_GrantType::Bundle;
	new(Union.Bundle.GetTypedPtr()) FPragma_Inventory_ItemBundleGrant(Value);
}

bool FPragma_Inventory_ProviderEntitlement_Grant::SerializeIntoParentJson(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	const FPragma_Inventory_ProviderEntitlement_Grant& OneOf = static_cast<const FPragma_Inventory_ProviderEntitlement*>(Value)->Grant;
	switch (OneOf.OneOfType())
	{
		case EPragma_Inventory_ProviderEntitlement_GrantType::Instanced:
			OutJsonObj->SetField("instanced", PragmaJson::StructToJsonValue(*OneOf.Union.Instanced.GetTypedPtr()));
			break;
		case EPragma_Inventory_ProviderEntitlement_GrantType::Stackable:
			OutJsonObj->SetField("stackable", PragmaJson::StructToJsonValue(*OneOf.Union.Stackable.GetTypedPtr()));
			break;
		case EPragma_Inventory_ProviderEntitlement_GrantType::Bundle:
			OutJsonObj->SetField("bundle", PragmaJson::StructToJsonValue(*OneOf.Union.Bundle.GetTypedPtr()));
			break;
		default:
			break;
	}
	// Per protobuf spec, it's ok to have empty oneof.
	return true;
}
bool FPragma_Inventory_ProviderEntitlement_Grant::DeserializeFromParentJson(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	FPragma_Inventory_ProviderEntitlement_Grant& OutOneOf = static_cast<FPragma_Inventory_ProviderEntitlement*>(OutValue)->Grant;
	if (JsonObj->HasField("instanced"))
	{
		OutOneOf.Type = EPragma_Inventory_ProviderEntitlement_GrantType::Instanced;
		new(OutOneOf.Union.Instanced.GetTypedPtr()) FPragma_Inventory_InstancedItemServerGrant(PragmaJson::JsonValueToStruct<FPragma_Inventory_InstancedItemServerGrant>(JsonObj->TryGetField(TEXT("instanced")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	if (JsonObj->HasField("stackable"))
	{
		OutOneOf.Type = EPragma_Inventory_ProviderEntitlement_GrantType::Stackable;
		new(OutOneOf.Union.Stackable.GetTypedPtr()) FPragma_Inventory_StackableItemGrant(PragmaJson::JsonValueToStruct<FPragma_Inventory_StackableItemGrant>(JsonObj->TryGetField(TEXT("stackable")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	if (JsonObj->HasField("bundle"))
	{
		OutOneOf.Type = EPragma_Inventory_ProviderEntitlement_GrantType::Bundle;
		new(OutOneOf.Union.Bundle.GetTypedPtr()) FPragma_Inventory_ItemBundleGrant(PragmaJson::JsonValueToStruct<FPragma_Inventory_ItemBundleGrant>(JsonObj->TryGetField(TEXT("bundle")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	// Per protobuf spec, oneofs have _at most_ one of the fields. None set is valid, so we always return true.
	return true;
}

bool operator==(const FPragma_Inventory_ProviderEntitlement_Grant& Lhs, const FPragma_Inventory_ProviderEntitlement_Grant& Rhs)
{
	return Lhs.Equals(Rhs);
}
bool operator!=(const FPragma_Inventory_ProviderEntitlement_Grant& Lhs, const FPragma_Inventory_ProviderEntitlement_Grant& Rhs)
{
	return !(Lhs == Rhs);
}


bool FPragma_Inventory_ProviderEntitlement::AddonSerializer(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	bool Success = true;
	Success &= FPragma_Inventory_ProviderEntitlement_Grant::SerializeIntoParentJson(Value, OutJsonObj);
	return Success;
}

bool FPragma_Inventory_ProviderEntitlement::AddonDeserializer(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	bool Success = true;
	Success &= FPragma_Inventory_ProviderEntitlement_Grant::DeserializeFromParentJson(JsonObj, OutValue);
	return Success;
}

bool operator==(const FPragma_Inventory_ProviderEntitlement& Lhs, const FPragma_Inventory_ProviderEntitlement& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.Id == Rhs.Id
			&& Lhs.ProviderDetails == Rhs.ProviderDetails
			&& Lhs.Grant == Rhs.Grant
;
}
bool operator!=(const FPragma_Inventory_ProviderEntitlement& Lhs, const FPragma_Inventory_ProviderEntitlement& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_ItemBundle& Lhs, const FPragma_Inventory_ItemBundle& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.Id == Rhs.Id
			&& Lhs.InstancedItems == Rhs.InstancedItems
			&& Lhs.StackableItems == Rhs.StackableItems
			&& Lhs.Tags == Rhs.Tags
;
}
bool operator!=(const FPragma_Inventory_ItemBundle& Lhs, const FPragma_Inventory_ItemBundle& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_UpdateEntry& Lhs, const FPragma_Inventory_UpdateEntry& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.Ext == Rhs.Ext
			&& Lhs.Id == Rhs.Id
			&& Lhs.CostByCatalogId.OrderIndependentCompareEqual(Rhs.CostByCatalogId)
			&& Lhs.Tags == Rhs.Tags
;
}
bool operator!=(const FPragma_Inventory_UpdateEntry& Lhs, const FPragma_Inventory_UpdateEntry& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_CraftingEntry& Lhs, const FPragma_Inventory_CraftingEntry& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.Ext == Rhs.Ext
			&& Lhs.Id == Rhs.Id
			&& Lhs.StackableCostByCatalogId.OrderIndependentCompareEqual(Rhs.StackableCostByCatalogId)
			&& Lhs.Tags == Rhs.Tags
			&& Lhs.Requirements == Rhs.Requirements
;
}
bool operator!=(const FPragma_Inventory_CraftingEntry& Lhs, const FPragma_Inventory_CraftingEntry& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_InstancedSpec& Lhs, const FPragma_Inventory_InstancedSpec& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.CatalogId == Rhs.CatalogId
			&& Lhs.Name == Rhs.Name
			&& Lhs.Tags == Rhs.Tags
			&& Lhs.Ext == Rhs.Ext
;
}
bool operator!=(const FPragma_Inventory_InstancedSpec& Lhs, const FPragma_Inventory_InstancedSpec& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_StackableSpec& Lhs, const FPragma_Inventory_StackableSpec& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.CatalogId == Rhs.CatalogId
			&& Lhs.Name == Rhs.Name
			&& Lhs.Limit == Rhs.Limit
			&& Lhs.Tags == Rhs.Tags
			&& Lhs.RemoveIfNone == Rhs.RemoveIfNone
			&& Lhs.Ext == Rhs.Ext
;
}
bool operator!=(const FPragma_Inventory_StackableSpec& Lhs, const FPragma_Inventory_StackableSpec& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_ItemCatalog& Lhs, const FPragma_Inventory_ItemCatalog& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.StackableEntries == Rhs.StackableEntries
			&& Lhs.InstancedEntries == Rhs.InstancedEntries
;
}
bool operator!=(const FPragma_Inventory_ItemCatalog& Lhs, const FPragma_Inventory_ItemCatalog& Rhs)
{
	return !(Lhs == Rhs);
}
