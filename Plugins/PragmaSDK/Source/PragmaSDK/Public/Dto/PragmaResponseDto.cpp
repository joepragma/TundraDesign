// <auto-generated>
//      Generated by Pragma Platform protoc-custom-plugins sdk-unreal4 target.  DO NOT EDIT!
//      Source template: unreal4/Dto.cpp.mustache
// </auto-generated>

#include "PragmaResponseDto.h"
#include "CoreMinimal.h"
#include "PragmaJson.h"


FPragma_ServiceError_ErrorType::FPragma_ServiceError_ErrorType() {}
FPragma_ServiceError_ErrorType::~FPragma_ServiceError_ErrorType()
{
	Reset();
}

FPragma_ServiceError_ErrorType::FPragma_ServiceError_ErrorType(const FPragma_ServiceError_ErrorType& Other)
{
	*this = Other;
}

bool FPragma_ServiceError_ErrorType::Equals(const FPragma_ServiceError_ErrorType& Other) const
{
    if (OneOfType() != Other.OneOfType())
    {
        return false;
    }
	switch (OneOfType())
	{
	case EPragma_ServiceError_ErrorTypeType::Error:
		return Error() == Other.Error();
	case EPragma_ServiceError_ErrorTypeType::ExtError:
		return ExtError() == Other.ExtError();
	case EPragma_ServiceError_ErrorTypeType::Invalid:
        return true;
	default:
		return false;
	}
}

FPragma_ServiceError_ErrorType& FPragma_ServiceError_ErrorType::operator=(const FPragma_ServiceError_ErrorType& Other)
{
	Reset();
	Type = Other.OneOfType();
	switch (Other.OneOfType())
	{
	case EPragma_ServiceError_ErrorTypeType::Error:
		new(Union.Error.GetTypedPtr()) EPragma_PlatformError(Other.Error());
		break;
	case EPragma_ServiceError_ErrorTypeType::ExtError:
		new(Union.ExtError.GetTypedPtr()) EPragma_ExtError(Other.ExtError());
		break;
	case EPragma_ServiceError_ErrorTypeType::Invalid:
	default:
		break;
	}
	return *this;
}

void FPragma_ServiceError_ErrorType::Reset()
{
	switch (OneOfType())
	{
	case EPragma_ServiceError_ErrorTypeType::Error:
		// Primitive type, no destructor.
		break;
	case EPragma_ServiceError_ErrorTypeType::ExtError:
		// Primitive type, no destructor.
		break;
	case EPragma_ServiceError_ErrorTypeType::Invalid:
	default:
		break;
	}
	Type = EPragma_ServiceError_ErrorTypeType::Invalid;
}

const EPragma_PlatformError& FPragma_ServiceError_ErrorType::Error() const {
	checkf(OneOfType() == EPragma_ServiceError_ErrorTypeType::Error, TEXT("Failed to retrieve Error from FPragma_ServiceError_ErrorType. Check the OneOfType() before accessing the value."));
	return *Union.Error.GetTypedPtr();
}
const EPragma_ExtError& FPragma_ServiceError_ErrorType::ExtError() const {
	checkf(OneOfType() == EPragma_ServiceError_ErrorTypeType::ExtError, TEXT("Failed to retrieve ExtError from FPragma_ServiceError_ErrorType. Check the OneOfType() before accessing the value."));
	return *Union.ExtError.GetTypedPtr();
}

void FPragma_ServiceError_ErrorType::SetError(const EPragma_PlatformError& Value)
{
	Reset();
	Type = EPragma_ServiceError_ErrorTypeType::Error;
	new(Union.Error.GetTypedPtr()) EPragma_PlatformError(Value);
}
void FPragma_ServiceError_ErrorType::SetExtError(const EPragma_ExtError& Value)
{
	Reset();
	Type = EPragma_ServiceError_ErrorTypeType::ExtError;
	new(Union.ExtError.GetTypedPtr()) EPragma_ExtError(Value);
}

bool FPragma_ServiceError_ErrorType::SerializeIntoParentJson(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	const FPragma_ServiceError_ErrorType& OneOf = static_cast<const FPragma_ServiceError*>(Value)->ErrorType;
	switch (OneOf.OneOfType())
	{
		case EPragma_ServiceError_ErrorTypeType::Error:
			OutJsonObj->SetField("error", PragmaJson::EnumToJsonValue(*OneOf.Union.Error.GetTypedPtr()));
			break;
		case EPragma_ServiceError_ErrorTypeType::ExtError:
			OutJsonObj->SetField("extError", PragmaJson::EnumToJsonValue(*OneOf.Union.ExtError.GetTypedPtr()));
			break;
		default:
			break;
	}
	// Per protobuf spec, it's ok to have empty oneof.
	return true;
}
bool FPragma_ServiceError_ErrorType::DeserializeFromParentJson(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	FPragma_ServiceError_ErrorType& OutOneOf = static_cast<FPragma_ServiceError*>(OutValue)->ErrorType;
	if (JsonObj->HasField("error"))
	{
		OutOneOf.Type = EPragma_ServiceError_ErrorTypeType::Error;
		new(OutOneOf.Union.Error.GetTypedPtr()) EPragma_PlatformError(PragmaJson::JsonValueToEnum<EPragma_PlatformError>(JsonObj->TryGetField(TEXT("error")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	if (JsonObj->HasField("extError"))
	{
		OutOneOf.Type = EPragma_ServiceError_ErrorTypeType::ExtError;
		new(OutOneOf.Union.ExtError.GetTypedPtr()) EPragma_ExtError(PragmaJson::JsonValueToEnum<EPragma_ExtError>(JsonObj->TryGetField(TEXT("extError")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	// Per protobuf spec, oneofs have _at most_ one of the fields. None set is valid, so we always return true.
	return true;
}

bool operator==(const FPragma_ServiceError_ErrorType& Lhs, const FPragma_ServiceError_ErrorType& Rhs)
{
	return Lhs.Equals(Rhs);
}
bool operator!=(const FPragma_ServiceError_ErrorType& Lhs, const FPragma_ServiceError_ErrorType& Rhs)
{
	return !(Lhs == Rhs);
}


bool FPragma_ServiceError::AddonSerializer(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	bool Success = true;
	Success &= FPragma_ServiceError_ErrorType::SerializeIntoParentJson(Value, OutJsonObj);
	return Success;
}

bool FPragma_ServiceError::AddonDeserializer(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	bool Success = true;
	Success &= FPragma_ServiceError_ErrorType::DeserializeFromParentJson(JsonObj, OutValue);
	return Success;
}

bool operator==(const FPragma_ServiceError& Lhs, const FPragma_ServiceError& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.RequestId == Rhs.RequestId
			&& Lhs.Status == Rhs.Status
			&& Lhs.TraceId == Rhs.TraceId
			&& Lhs.DebugDetails == Rhs.DebugDetails
			&& Lhs.ErrorType == Rhs.ErrorType
;
}
bool operator!=(const FPragma_ServiceError& Lhs, const FPragma_ServiceError& Rhs)
{
	return !(Lhs == Rhs);
}
