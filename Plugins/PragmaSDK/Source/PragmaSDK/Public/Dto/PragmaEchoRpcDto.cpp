// <auto-generated>
//      Generated by Pragma Platform protoc-custom-plugins sdk-unreal4 target.  DO NOT EDIT!
//      Source template: unreal4/Dto.cpp.mustache
// </auto-generated>

#include "PragmaEchoRpcDto.h"
#include "CoreMinimal.h"
#include "PragmaJson.h"



bool operator==(const FPragma_Echo_EchoV1Request& Lhs, const FPragma_Echo_EchoV1Request& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.Message == Rhs.Message
;
}
bool operator!=(const FPragma_Echo_EchoV1Request& Lhs, const FPragma_Echo_EchoV1Request& Rhs)
{
	return !(Lhs == Rhs);
}

FPragma_Echo_EchoV1Response_Artifact::FPragma_Echo_EchoV1Response_Artifact() {}
FPragma_Echo_EchoV1Response_Artifact::~FPragma_Echo_EchoV1Response_Artifact()
{
	Reset();
}

FPragma_Echo_EchoV1Response_Artifact::FPragma_Echo_EchoV1Response_Artifact(const FPragma_Echo_EchoV1Response_Artifact& Other)
{
	*this = Other;
}

bool FPragma_Echo_EchoV1Response_Artifact::Equals(const FPragma_Echo_EchoV1Response_Artifact& Other) const
{
	if (!HasValue() && !Other.HasValue())
	{
		return true;
	}
	if (HasValue() != Other.HasValue())
	{
		return false;
	}
	return *ValuePtr == *Other.ValuePtr;
}

FPragma_Echo_EchoV1Response_Artifact& FPragma_Echo_EchoV1Response_Artifact::operator=(const FPragma_Echo_EchoV1Response_Artifact& Other)
{
	if (Other.HasValue())
	{
		SetValue(Other.Value());
	}
	else
	{
		Reset();
	}
	return *this;
}

void FPragma_Echo_EchoV1Response_Artifact::Reset()
{
	ValuePtr.Reset();
}

const FPragma_Echo_EchoV1Request& FPragma_Echo_EchoV1Response_Artifact::Value() const {
	checkf(HasValue(), TEXT("Failed to retrieve Artifact from FPragma_Echo_EchoV1Response_Artifact. Check HasValue() first."));
	return *ValuePtr;
}

void FPragma_Echo_EchoV1Response_Artifact::SetValue(const FPragma_Echo_EchoV1Request& Value)
{
	ValuePtr.Reset(new FPragma_Echo_EchoV1Request{Value});
}

bool FPragma_Echo_EchoV1Response_Artifact::SerializeIntoParentJson(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	const FPragma_Echo_EchoV1Response_Artifact& Optional = static_cast<const FPragma_Echo_EchoV1Response*>(Value)->Artifact;
	if (Optional.HasValue())
	{
		OutJsonObj->SetField("artifact", PragmaJson::StructToJsonValue(Optional.Value()));
	}
	return true;
}
bool FPragma_Echo_EchoV1Response_Artifact::DeserializeFromParentJson(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	FPragma_Echo_EchoV1Response_Artifact& OutOptional = static_cast<FPragma_Echo_EchoV1Response*>(OutValue)->Artifact;
	if (JsonObj->HasField("artifact"))
	{
		OutOptional.ValuePtr.Reset(new FPragma_Echo_EchoV1Request{PragmaJson::JsonValueToStruct<FPragma_Echo_EchoV1Request>(JsonObj->TryGetField(TEXT("artifact")).ToSharedRef())});
	}
	return true;
}

bool operator==(const FPragma_Echo_EchoV1Response_Artifact& Lhs, const FPragma_Echo_EchoV1Response_Artifact& Rhs)
{
	return Lhs.Equals(Rhs);
}
bool operator!=(const FPragma_Echo_EchoV1Response_Artifact& Lhs, const FPragma_Echo_EchoV1Response_Artifact& Rhs)
{
	return !(Lhs == Rhs);
}


bool FPragma_Echo_EchoV1Response::AddonSerializer(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	bool Success = true;
	Success &= FPragma_Echo_EchoV1Response_Artifact::SerializeIntoParentJson(Value, OutJsonObj);
	return Success;
}

bool FPragma_Echo_EchoV1Response::AddonDeserializer(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	bool Success = true;
	Success &= FPragma_Echo_EchoV1Response_Artifact::DeserializeFromParentJson(JsonObj, OutValue);
	return Success;
}

bool operator==(const FPragma_Echo_EchoV1Response& Lhs, const FPragma_Echo_EchoV1Response& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.ResponseMessage == Rhs.ResponseMessage
			&& Lhs.Artifact == Rhs.Artifact
;
}
bool operator!=(const FPragma_Echo_EchoV1Response& Lhs, const FPragma_Echo_EchoV1Response& Rhs)
{
	return !(Lhs == Rhs);
}
