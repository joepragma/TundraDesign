// <auto-generated>
//      Generated by Pragma Platform protoc-custom-plugins sdk-unreal4 target.  DO NOT EDIT!
//      Source template: unreal4/Dto.cpp.mustache
// </auto-generated>

#include "PragmaInventoryExtDto.h"
#include "CoreMinimal.h"
#include "PragmaJson.h"



bool operator==(const FPragma_Inventory_PetEvolutionRequest& Lhs, const FPragma_Inventory_PetEvolutionRequest& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.CraftingLocation == Rhs.CraftingLocation
;
}
bool operator!=(const FPragma_Inventory_PetEvolutionRequest& Lhs, const FPragma_Inventory_PetEvolutionRequest& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_TrackingItem& Lhs, const FPragma_Inventory_TrackingItem& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.InstanceIds == Rhs.InstanceIds
;
}
bool operator!=(const FPragma_Inventory_TrackingItem& Lhs, const FPragma_Inventory_TrackingItem& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_Gear& Lhs, const FPragma_Inventory_Gear& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.Xp == Rhs.Xp
			&& Lhs.BonusMultiplier == Rhs.BonusMultiplier
;
}
bool operator!=(const FPragma_Inventory_Gear& Lhs, const FPragma_Inventory_Gear& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_IncompleteFood& Lhs, const FPragma_Inventory_IncompleteFood& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.TimestampMillis == Rhs.TimestampMillis
;
}
bool operator!=(const FPragma_Inventory_IncompleteFood& Lhs, const FPragma_Inventory_IncompleteFood& Rhs)
{
	return !(Lhs == Rhs);
}

FPragma_Inventory_ExtInstancedItem_Data::FPragma_Inventory_ExtInstancedItem_Data() {}
FPragma_Inventory_ExtInstancedItem_Data::~FPragma_Inventory_ExtInstancedItem_Data()
{
	Reset();
}

FPragma_Inventory_ExtInstancedItem_Data::FPragma_Inventory_ExtInstancedItem_Data(const FPragma_Inventory_ExtInstancedItem_Data& Other)
{
	*this = Other;
}

bool FPragma_Inventory_ExtInstancedItem_Data::Equals(const FPragma_Inventory_ExtInstancedItem_Data& Other) const
{
    if (OneOfType() != Other.OneOfType())
    {
        return false;
    }
	switch (OneOfType())
	{
	case EPragma_Inventory_ExtInstancedItem_DataType::Pet:
		return Pet() == Other.Pet();
	case EPragma_Inventory_ExtInstancedItem_DataType::IncompleteFood:
		return IncompleteFood() == Other.IncompleteFood();
	case EPragma_Inventory_ExtInstancedItem_DataType::ActiveMissions:
		return ActiveMissions() == Other.ActiveMissions();
	case EPragma_Inventory_ExtInstancedItem_DataType::Gear:
		return Gear() == Other.Gear();
	case EPragma_Inventory_ExtInstancedItem_DataType::TrackingItem:
		return TrackingItem() == Other.TrackingItem();
	case EPragma_Inventory_ExtInstancedItem_DataType::Invalid:
        return true;
	default:
		return false;
	}
}

FPragma_Inventory_ExtInstancedItem_Data& FPragma_Inventory_ExtInstancedItem_Data::operator=(const FPragma_Inventory_ExtInstancedItem_Data& Other)
{
	Reset();
	Type = Other.OneOfType();
	switch (Other.OneOfType())
	{
	case EPragma_Inventory_ExtInstancedItem_DataType::Pet:
		new(Union.Pet.GetTypedPtr()) FPragma_Inventory_Pet(Other.Pet());
		break;
	case EPragma_Inventory_ExtInstancedItem_DataType::IncompleteFood:
		new(Union.IncompleteFood.GetTypedPtr()) FPragma_Inventory_IncompleteFood(Other.IncompleteFood());
		break;
	case EPragma_Inventory_ExtInstancedItem_DataType::ActiveMissions:
		new(Union.ActiveMissions.GetTypedPtr()) FPragma_Ext_ActiveMissions(Other.ActiveMissions());
		break;
	case EPragma_Inventory_ExtInstancedItem_DataType::Gear:
		new(Union.Gear.GetTypedPtr()) FPragma_Inventory_Gear(Other.Gear());
		break;
	case EPragma_Inventory_ExtInstancedItem_DataType::TrackingItem:
		new(Union.TrackingItem.GetTypedPtr()) FPragma_Inventory_TrackingItem(Other.TrackingItem());
		break;
	case EPragma_Inventory_ExtInstancedItem_DataType::Invalid:
	default:
		break;
	}
	return *this;
}

void FPragma_Inventory_ExtInstancedItem_Data::Reset()
{
	switch (OneOfType())
	{
	case EPragma_Inventory_ExtInstancedItem_DataType::Pet:
		Union.Pet.GetTypedPtr()->~FPragma_Inventory_Pet();
		break;
	case EPragma_Inventory_ExtInstancedItem_DataType::IncompleteFood:
		Union.IncompleteFood.GetTypedPtr()->~FPragma_Inventory_IncompleteFood();
		break;
	case EPragma_Inventory_ExtInstancedItem_DataType::ActiveMissions:
		Union.ActiveMissions.GetTypedPtr()->~FPragma_Ext_ActiveMissions();
		break;
	case EPragma_Inventory_ExtInstancedItem_DataType::Gear:
		Union.Gear.GetTypedPtr()->~FPragma_Inventory_Gear();
		break;
	case EPragma_Inventory_ExtInstancedItem_DataType::TrackingItem:
		Union.TrackingItem.GetTypedPtr()->~FPragma_Inventory_TrackingItem();
		break;
	case EPragma_Inventory_ExtInstancedItem_DataType::Invalid:
	default:
		break;
	}
	Type = EPragma_Inventory_ExtInstancedItem_DataType::Invalid;
}

const FPragma_Inventory_Pet& FPragma_Inventory_ExtInstancedItem_Data::Pet() const {
	checkf(OneOfType() == EPragma_Inventory_ExtInstancedItem_DataType::Pet, TEXT("Failed to retrieve Pet from FPragma_Inventory_ExtInstancedItem_Data. Check the OneOfType() before accessing the value."));
	return *Union.Pet.GetTypedPtr();
}
const FPragma_Inventory_IncompleteFood& FPragma_Inventory_ExtInstancedItem_Data::IncompleteFood() const {
	checkf(OneOfType() == EPragma_Inventory_ExtInstancedItem_DataType::IncompleteFood, TEXT("Failed to retrieve IncompleteFood from FPragma_Inventory_ExtInstancedItem_Data. Check the OneOfType() before accessing the value."));
	return *Union.IncompleteFood.GetTypedPtr();
}
const FPragma_Ext_ActiveMissions& FPragma_Inventory_ExtInstancedItem_Data::ActiveMissions() const {
	checkf(OneOfType() == EPragma_Inventory_ExtInstancedItem_DataType::ActiveMissions, TEXT("Failed to retrieve ActiveMissions from FPragma_Inventory_ExtInstancedItem_Data. Check the OneOfType() before accessing the value."));
	return *Union.ActiveMissions.GetTypedPtr();
}
const FPragma_Inventory_Gear& FPragma_Inventory_ExtInstancedItem_Data::Gear() const {
	checkf(OneOfType() == EPragma_Inventory_ExtInstancedItem_DataType::Gear, TEXT("Failed to retrieve Gear from FPragma_Inventory_ExtInstancedItem_Data. Check the OneOfType() before accessing the value."));
	return *Union.Gear.GetTypedPtr();
}
const FPragma_Inventory_TrackingItem& FPragma_Inventory_ExtInstancedItem_Data::TrackingItem() const {
	checkf(OneOfType() == EPragma_Inventory_ExtInstancedItem_DataType::TrackingItem, TEXT("Failed to retrieve TrackingItem from FPragma_Inventory_ExtInstancedItem_Data. Check the OneOfType() before accessing the value."));
	return *Union.TrackingItem.GetTypedPtr();
}

void FPragma_Inventory_ExtInstancedItem_Data::SetPet(const FPragma_Inventory_Pet& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtInstancedItem_DataType::Pet;
	new(Union.Pet.GetTypedPtr()) FPragma_Inventory_Pet(Value);
}
void FPragma_Inventory_ExtInstancedItem_Data::SetIncompleteFood(const FPragma_Inventory_IncompleteFood& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtInstancedItem_DataType::IncompleteFood;
	new(Union.IncompleteFood.GetTypedPtr()) FPragma_Inventory_IncompleteFood(Value);
}
void FPragma_Inventory_ExtInstancedItem_Data::SetActiveMissions(const FPragma_Ext_ActiveMissions& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtInstancedItem_DataType::ActiveMissions;
	new(Union.ActiveMissions.GetTypedPtr()) FPragma_Ext_ActiveMissions(Value);
}
void FPragma_Inventory_ExtInstancedItem_Data::SetGear(const FPragma_Inventory_Gear& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtInstancedItem_DataType::Gear;
	new(Union.Gear.GetTypedPtr()) FPragma_Inventory_Gear(Value);
}
void FPragma_Inventory_ExtInstancedItem_Data::SetTrackingItem(const FPragma_Inventory_TrackingItem& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtInstancedItem_DataType::TrackingItem;
	new(Union.TrackingItem.GetTypedPtr()) FPragma_Inventory_TrackingItem(Value);
}

bool FPragma_Inventory_ExtInstancedItem_Data::SerializeIntoParentJson(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	const FPragma_Inventory_ExtInstancedItem_Data& OneOf = static_cast<const FPragma_Inventory_ExtInstancedItem*>(Value)->Data;
	switch (OneOf.OneOfType())
	{
		case EPragma_Inventory_ExtInstancedItem_DataType::Pet:
			OutJsonObj->SetField("pet", PragmaJson::StructToJsonValue(*OneOf.Union.Pet.GetTypedPtr()));
			break;
		case EPragma_Inventory_ExtInstancedItem_DataType::IncompleteFood:
			OutJsonObj->SetField("incompleteFood", PragmaJson::StructToJsonValue(*OneOf.Union.IncompleteFood.GetTypedPtr()));
			break;
		case EPragma_Inventory_ExtInstancedItem_DataType::ActiveMissions:
			OutJsonObj->SetField("activeMissions", PragmaJson::StructToJsonValue(*OneOf.Union.ActiveMissions.GetTypedPtr()));
			break;
		case EPragma_Inventory_ExtInstancedItem_DataType::Gear:
			OutJsonObj->SetField("gear", PragmaJson::StructToJsonValue(*OneOf.Union.Gear.GetTypedPtr()));
			break;
		case EPragma_Inventory_ExtInstancedItem_DataType::TrackingItem:
			OutJsonObj->SetField("trackingItem", PragmaJson::StructToJsonValue(*OneOf.Union.TrackingItem.GetTypedPtr()));
			break;
		default:
			break;
	}
	// Per protobuf spec, it's ok to have empty oneof.
	return true;
}
bool FPragma_Inventory_ExtInstancedItem_Data::DeserializeFromParentJson(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	FPragma_Inventory_ExtInstancedItem_Data& OutOneOf = static_cast<FPragma_Inventory_ExtInstancedItem*>(OutValue)->Data;
	if (JsonObj->HasField("pet"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtInstancedItem_DataType::Pet;
		new(OutOneOf.Union.Pet.GetTypedPtr()) FPragma_Inventory_Pet(PragmaJson::JsonValueToStruct<FPragma_Inventory_Pet>(JsonObj->TryGetField(TEXT("pet")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	if (JsonObj->HasField("incompleteFood"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtInstancedItem_DataType::IncompleteFood;
		new(OutOneOf.Union.IncompleteFood.GetTypedPtr()) FPragma_Inventory_IncompleteFood(PragmaJson::JsonValueToStruct<FPragma_Inventory_IncompleteFood>(JsonObj->TryGetField(TEXT("incompleteFood")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	if (JsonObj->HasField("activeMissions"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtInstancedItem_DataType::ActiveMissions;
		new(OutOneOf.Union.ActiveMissions.GetTypedPtr()) FPragma_Ext_ActiveMissions(PragmaJson::JsonValueToStruct<FPragma_Ext_ActiveMissions>(JsonObj->TryGetField(TEXT("activeMissions")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	if (JsonObj->HasField("gear"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtInstancedItem_DataType::Gear;
		new(OutOneOf.Union.Gear.GetTypedPtr()) FPragma_Inventory_Gear(PragmaJson::JsonValueToStruct<FPragma_Inventory_Gear>(JsonObj->TryGetField(TEXT("gear")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	if (JsonObj->HasField("trackingItem"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtInstancedItem_DataType::TrackingItem;
		new(OutOneOf.Union.TrackingItem.GetTypedPtr()) FPragma_Inventory_TrackingItem(PragmaJson::JsonValueToStruct<FPragma_Inventory_TrackingItem>(JsonObj->TryGetField(TEXT("trackingItem")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	// Per protobuf spec, oneofs have _at most_ one of the fields. None set is valid, so we always return true.
	return true;
}

bool operator==(const FPragma_Inventory_ExtInstancedItem_Data& Lhs, const FPragma_Inventory_ExtInstancedItem_Data& Rhs)
{
	return Lhs.Equals(Rhs);
}
bool operator!=(const FPragma_Inventory_ExtInstancedItem_Data& Lhs, const FPragma_Inventory_ExtInstancedItem_Data& Rhs)
{
	return !(Lhs == Rhs);
}


bool FPragma_Inventory_ExtInstancedItem::AddonSerializer(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	bool Success = true;
	Success &= FPragma_Inventory_ExtInstancedItem_Data::SerializeIntoParentJson(Value, OutJsonObj);
	return Success;
}

bool FPragma_Inventory_ExtInstancedItem::AddonDeserializer(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	bool Success = true;
	Success &= FPragma_Inventory_ExtInstancedItem_Data::DeserializeFromParentJson(JsonObj, OutValue);
	return Success;
}

bool operator==(const FPragma_Inventory_ExtInstancedItem& Lhs, const FPragma_Inventory_ExtInstancedItem& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.Data == Rhs.Data
;
}
bool operator!=(const FPragma_Inventory_ExtInstancedItem& Lhs, const FPragma_Inventory_ExtInstancedItem& Rhs)
{
	return !(Lhs == Rhs);
}
