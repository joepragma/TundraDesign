// <auto-generated>
//      Generated by Pragma Platform protoc-custom-plugins sdk-unreal4 target.  DO NOT EDIT!
//      Source template: unreal4/Dto.cpp.mustache
// </auto-generated>

#include "PragmaInventoryContentExtDto.h"
#include "CoreMinimal.h"
#include "PragmaJson.h"



bool operator==(const FPragma_Inventory_DemoCustomEntitlement& Lhs, const FPragma_Inventory_DemoCustomEntitlement& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.Id == Rhs.Id
;
}
bool operator!=(const FPragma_Inventory_DemoCustomEntitlement& Lhs, const FPragma_Inventory_DemoCustomEntitlement& Rhs)
{
	return !(Lhs == Rhs);
}

FPragma_Inventory_ExtEntitlement_Data::FPragma_Inventory_ExtEntitlement_Data() {}
FPragma_Inventory_ExtEntitlement_Data::~FPragma_Inventory_ExtEntitlement_Data()
{
	Reset();
}

FPragma_Inventory_ExtEntitlement_Data::FPragma_Inventory_ExtEntitlement_Data(const FPragma_Inventory_ExtEntitlement_Data& Other)
{
	*this = Other;
}

bool FPragma_Inventory_ExtEntitlement_Data::Equals(const FPragma_Inventory_ExtEntitlement_Data& Other) const
{
    if (OneOfType() != Other.OneOfType())
    {
        return false;
    }
	switch (OneOfType())
	{
	case EPragma_Inventory_ExtEntitlement_DataType::DemoCustomEntitlement:
		return DemoCustomEntitlement() == Other.DemoCustomEntitlement();
	case EPragma_Inventory_ExtEntitlement_DataType::PlaystationEntitlement:
		return PlaystationEntitlement() == Other.PlaystationEntitlement();
	case EPragma_Inventory_ExtEntitlement_DataType::XboxEntitlement:
		return XboxEntitlement() == Other.XboxEntitlement();
	case EPragma_Inventory_ExtEntitlement_DataType::Invalid:
        return true;
	default:
		return false;
	}
}

FPragma_Inventory_ExtEntitlement_Data& FPragma_Inventory_ExtEntitlement_Data::operator=(const FPragma_Inventory_ExtEntitlement_Data& Other)
{
	Reset();
	Type = Other.OneOfType();
	switch (Other.OneOfType())
	{
	case EPragma_Inventory_ExtEntitlement_DataType::DemoCustomEntitlement:
		new(Union.DemoCustomEntitlement.GetTypedPtr()) FPragma_Inventory_DemoCustomEntitlement(Other.DemoCustomEntitlement());
		break;
	case EPragma_Inventory_ExtEntitlement_DataType::PlaystationEntitlement:
		new(Union.PlaystationEntitlement.GetTypedPtr()) FPragma_Playstation_PlaystationEntitlement(Other.PlaystationEntitlement());
		break;
	case EPragma_Inventory_ExtEntitlement_DataType::XboxEntitlement:
		new(Union.XboxEntitlement.GetTypedPtr()) FPragma_Xbox_XboxEntitlement(Other.XboxEntitlement());
		break;
	case EPragma_Inventory_ExtEntitlement_DataType::Invalid:
	default:
		break;
	}
	return *this;
}

void FPragma_Inventory_ExtEntitlement_Data::Reset()
{
	switch (OneOfType())
	{
	case EPragma_Inventory_ExtEntitlement_DataType::DemoCustomEntitlement:
		Union.DemoCustomEntitlement.GetTypedPtr()->~FPragma_Inventory_DemoCustomEntitlement();
		break;
	case EPragma_Inventory_ExtEntitlement_DataType::PlaystationEntitlement:
		Union.PlaystationEntitlement.GetTypedPtr()->~FPragma_Playstation_PlaystationEntitlement();
		break;
	case EPragma_Inventory_ExtEntitlement_DataType::XboxEntitlement:
		Union.XboxEntitlement.GetTypedPtr()->~FPragma_Xbox_XboxEntitlement();
		break;
	case EPragma_Inventory_ExtEntitlement_DataType::Invalid:
	default:
		break;
	}
	Type = EPragma_Inventory_ExtEntitlement_DataType::Invalid;
}

const FPragma_Inventory_DemoCustomEntitlement& FPragma_Inventory_ExtEntitlement_Data::DemoCustomEntitlement() const {
	checkf(OneOfType() == EPragma_Inventory_ExtEntitlement_DataType::DemoCustomEntitlement, TEXT("Failed to retrieve DemoCustomEntitlement from FPragma_Inventory_ExtEntitlement_Data. Check the OneOfType() before accessing the value."));
	return *Union.DemoCustomEntitlement.GetTypedPtr();
}
const FPragma_Playstation_PlaystationEntitlement& FPragma_Inventory_ExtEntitlement_Data::PlaystationEntitlement() const {
	checkf(OneOfType() == EPragma_Inventory_ExtEntitlement_DataType::PlaystationEntitlement, TEXT("Failed to retrieve PlaystationEntitlement from FPragma_Inventory_ExtEntitlement_Data. Check the OneOfType() before accessing the value."));
	return *Union.PlaystationEntitlement.GetTypedPtr();
}
const FPragma_Xbox_XboxEntitlement& FPragma_Inventory_ExtEntitlement_Data::XboxEntitlement() const {
	checkf(OneOfType() == EPragma_Inventory_ExtEntitlement_DataType::XboxEntitlement, TEXT("Failed to retrieve XboxEntitlement from FPragma_Inventory_ExtEntitlement_Data. Check the OneOfType() before accessing the value."));
	return *Union.XboxEntitlement.GetTypedPtr();
}

void FPragma_Inventory_ExtEntitlement_Data::SetDemoCustomEntitlement(const FPragma_Inventory_DemoCustomEntitlement& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtEntitlement_DataType::DemoCustomEntitlement;
	new(Union.DemoCustomEntitlement.GetTypedPtr()) FPragma_Inventory_DemoCustomEntitlement(Value);
}
void FPragma_Inventory_ExtEntitlement_Data::SetPlaystationEntitlement(const FPragma_Playstation_PlaystationEntitlement& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtEntitlement_DataType::PlaystationEntitlement;
	new(Union.PlaystationEntitlement.GetTypedPtr()) FPragma_Playstation_PlaystationEntitlement(Value);
}
void FPragma_Inventory_ExtEntitlement_Data::SetXboxEntitlement(const FPragma_Xbox_XboxEntitlement& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtEntitlement_DataType::XboxEntitlement;
	new(Union.XboxEntitlement.GetTypedPtr()) FPragma_Xbox_XboxEntitlement(Value);
}

bool FPragma_Inventory_ExtEntitlement_Data::SerializeIntoParentJson(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	const FPragma_Inventory_ExtEntitlement_Data& OneOf = static_cast<const FPragma_Inventory_ExtEntitlement*>(Value)->Data;
	switch (OneOf.OneOfType())
	{
		case EPragma_Inventory_ExtEntitlement_DataType::DemoCustomEntitlement:
			OutJsonObj->SetField("demoCustomEntitlement", PragmaJson::StructToJsonValue(*OneOf.Union.DemoCustomEntitlement.GetTypedPtr()));
			break;
		case EPragma_Inventory_ExtEntitlement_DataType::PlaystationEntitlement:
			OutJsonObj->SetField("playstationEntitlement", PragmaJson::StructToJsonValue(*OneOf.Union.PlaystationEntitlement.GetTypedPtr()));
			break;
		case EPragma_Inventory_ExtEntitlement_DataType::XboxEntitlement:
			OutJsonObj->SetField("xboxEntitlement", PragmaJson::StructToJsonValue(*OneOf.Union.XboxEntitlement.GetTypedPtr()));
			break;
		default:
			break;
	}
	// Per protobuf spec, it's ok to have empty oneof.
	return true;
}
bool FPragma_Inventory_ExtEntitlement_Data::DeserializeFromParentJson(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	FPragma_Inventory_ExtEntitlement_Data& OutOneOf = static_cast<FPragma_Inventory_ExtEntitlement*>(OutValue)->Data;
	if (JsonObj->HasField("demoCustomEntitlement"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtEntitlement_DataType::DemoCustomEntitlement;
		new(OutOneOf.Union.DemoCustomEntitlement.GetTypedPtr()) FPragma_Inventory_DemoCustomEntitlement(PragmaJson::JsonValueToStruct<FPragma_Inventory_DemoCustomEntitlement>(JsonObj->TryGetField(TEXT("demoCustomEntitlement")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	if (JsonObj->HasField("playstationEntitlement"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtEntitlement_DataType::PlaystationEntitlement;
		new(OutOneOf.Union.PlaystationEntitlement.GetTypedPtr()) FPragma_Playstation_PlaystationEntitlement(PragmaJson::JsonValueToStruct<FPragma_Playstation_PlaystationEntitlement>(JsonObj->TryGetField(TEXT("playstationEntitlement")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	if (JsonObj->HasField("xboxEntitlement"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtEntitlement_DataType::XboxEntitlement;
		new(OutOneOf.Union.XboxEntitlement.GetTypedPtr()) FPragma_Xbox_XboxEntitlement(PragmaJson::JsonValueToStruct<FPragma_Xbox_XboxEntitlement>(JsonObj->TryGetField(TEXT("xboxEntitlement")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	// Per protobuf spec, oneofs have _at most_ one of the fields. None set is valid, so we always return true.
	return true;
}

bool operator==(const FPragma_Inventory_ExtEntitlement_Data& Lhs, const FPragma_Inventory_ExtEntitlement_Data& Rhs)
{
	return Lhs.Equals(Rhs);
}
bool operator!=(const FPragma_Inventory_ExtEntitlement_Data& Lhs, const FPragma_Inventory_ExtEntitlement_Data& Rhs)
{
	return !(Lhs == Rhs);
}


bool FPragma_Inventory_ExtEntitlement::AddonSerializer(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	bool Success = true;
	Success &= FPragma_Inventory_ExtEntitlement_Data::SerializeIntoParentJson(Value, OutJsonObj);
	return Success;
}

bool FPragma_Inventory_ExtEntitlement::AddonDeserializer(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	bool Success = true;
	Success &= FPragma_Inventory_ExtEntitlement_Data::DeserializeFromParentJson(JsonObj, OutValue);
	return Success;
}

bool operator==(const FPragma_Inventory_ExtEntitlement& Lhs, const FPragma_Inventory_ExtEntitlement& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.Data == Rhs.Data
;
}
bool operator!=(const FPragma_Inventory_ExtEntitlement& Lhs, const FPragma_Inventory_ExtEntitlement& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_MissionSpec& Lhs, const FPragma_Inventory_MissionSpec& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.Objectives.OrderIndependentCompareEqual(Rhs.Objectives)
			&& Lhs.DemoItemGrants == Rhs.DemoItemGrants
;
}
bool operator!=(const FPragma_Inventory_MissionSpec& Lhs, const FPragma_Inventory_MissionSpec& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_DemoMissionItemUpdate& Lhs, const FPragma_Inventory_DemoMissionItemUpdate& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.CatalogId == Rhs.CatalogId
			&& Lhs.MissionsUpdate == Rhs.MissionsUpdate
;
}
bool operator!=(const FPragma_Inventory_DemoMissionItemUpdate& Lhs, const FPragma_Inventory_DemoMissionItemUpdate& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_DemoRewardGrant& Lhs, const FPragma_Inventory_DemoRewardGrant& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.TableId == Rhs.TableId
			&& Lhs.Count == Rhs.Count
			&& Lhs.Tags == Rhs.Tags
;
}
bool operator!=(const FPragma_Inventory_DemoRewardGrant& Lhs, const FPragma_Inventory_DemoRewardGrant& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_PetUpdateSpec& Lhs, const FPragma_Inventory_PetUpdateSpec& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.DemoItemGrants == Rhs.DemoItemGrants
			&& Lhs.DemoRewardGrants == Rhs.DemoRewardGrants
			&& Lhs.DemoMissionItemUpdate == Rhs.DemoMissionItemUpdate
;
}
bool operator!=(const FPragma_Inventory_PetUpdateSpec& Lhs, const FPragma_Inventory_PetUpdateSpec& Rhs)
{
	return !(Lhs == Rhs);
}

FPragma_Inventory_ExtUpdateEntry_Data::FPragma_Inventory_ExtUpdateEntry_Data() {}
FPragma_Inventory_ExtUpdateEntry_Data::~FPragma_Inventory_ExtUpdateEntry_Data()
{
	Reset();
}

FPragma_Inventory_ExtUpdateEntry_Data::FPragma_Inventory_ExtUpdateEntry_Data(const FPragma_Inventory_ExtUpdateEntry_Data& Other)
{
	*this = Other;
}

bool FPragma_Inventory_ExtUpdateEntry_Data::Equals(const FPragma_Inventory_ExtUpdateEntry_Data& Other) const
{
    if (OneOfType() != Other.OneOfType())
    {
        return false;
    }
	switch (OneOfType())
	{
	case EPragma_Inventory_ExtUpdateEntry_DataType::PetUpdateSpec:
		return PetUpdateSpec() == Other.PetUpdateSpec();
	case EPragma_Inventory_ExtUpdateEntry_DataType::Invalid:
        return true;
	default:
		return false;
	}
}

FPragma_Inventory_ExtUpdateEntry_Data& FPragma_Inventory_ExtUpdateEntry_Data::operator=(const FPragma_Inventory_ExtUpdateEntry_Data& Other)
{
	Reset();
	Type = Other.OneOfType();
	switch (Other.OneOfType())
	{
	case EPragma_Inventory_ExtUpdateEntry_DataType::PetUpdateSpec:
		new(Union.PetUpdateSpec.GetTypedPtr()) FPragma_Inventory_PetUpdateSpec(Other.PetUpdateSpec());
		break;
	case EPragma_Inventory_ExtUpdateEntry_DataType::Invalid:
	default:
		break;
	}
	return *this;
}

void FPragma_Inventory_ExtUpdateEntry_Data::Reset()
{
	switch (OneOfType())
	{
	case EPragma_Inventory_ExtUpdateEntry_DataType::PetUpdateSpec:
		Union.PetUpdateSpec.GetTypedPtr()->~FPragma_Inventory_PetUpdateSpec();
		break;
	case EPragma_Inventory_ExtUpdateEntry_DataType::Invalid:
	default:
		break;
	}
	Type = EPragma_Inventory_ExtUpdateEntry_DataType::Invalid;
}

const FPragma_Inventory_PetUpdateSpec& FPragma_Inventory_ExtUpdateEntry_Data::PetUpdateSpec() const {
	checkf(OneOfType() == EPragma_Inventory_ExtUpdateEntry_DataType::PetUpdateSpec, TEXT("Failed to retrieve PetUpdateSpec from FPragma_Inventory_ExtUpdateEntry_Data. Check the OneOfType() before accessing the value."));
	return *Union.PetUpdateSpec.GetTypedPtr();
}

void FPragma_Inventory_ExtUpdateEntry_Data::SetPetUpdateSpec(const FPragma_Inventory_PetUpdateSpec& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtUpdateEntry_DataType::PetUpdateSpec;
	new(Union.PetUpdateSpec.GetTypedPtr()) FPragma_Inventory_PetUpdateSpec(Value);
}

bool FPragma_Inventory_ExtUpdateEntry_Data::SerializeIntoParentJson(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	const FPragma_Inventory_ExtUpdateEntry_Data& OneOf = static_cast<const FPragma_Inventory_ExtUpdateEntry*>(Value)->Data;
	switch (OneOf.OneOfType())
	{
		case EPragma_Inventory_ExtUpdateEntry_DataType::PetUpdateSpec:
			OutJsonObj->SetField("petUpdateSpec", PragmaJson::StructToJsonValue(*OneOf.Union.PetUpdateSpec.GetTypedPtr()));
			break;
		default:
			break;
	}
	// Per protobuf spec, it's ok to have empty oneof.
	return true;
}
bool FPragma_Inventory_ExtUpdateEntry_Data::DeserializeFromParentJson(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	FPragma_Inventory_ExtUpdateEntry_Data& OutOneOf = static_cast<FPragma_Inventory_ExtUpdateEntry*>(OutValue)->Data;
	if (JsonObj->HasField("petUpdateSpec"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtUpdateEntry_DataType::PetUpdateSpec;
		new(OutOneOf.Union.PetUpdateSpec.GetTypedPtr()) FPragma_Inventory_PetUpdateSpec(PragmaJson::JsonValueToStruct<FPragma_Inventory_PetUpdateSpec>(JsonObj->TryGetField(TEXT("petUpdateSpec")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	// Per protobuf spec, oneofs have _at most_ one of the fields. None set is valid, so we always return true.
	return true;
}

bool operator==(const FPragma_Inventory_ExtUpdateEntry_Data& Lhs, const FPragma_Inventory_ExtUpdateEntry_Data& Rhs)
{
	return Lhs.Equals(Rhs);
}
bool operator!=(const FPragma_Inventory_ExtUpdateEntry_Data& Lhs, const FPragma_Inventory_ExtUpdateEntry_Data& Rhs)
{
	return !(Lhs == Rhs);
}


bool FPragma_Inventory_ExtUpdateEntry::AddonSerializer(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	bool Success = true;
	Success &= FPragma_Inventory_ExtUpdateEntry_Data::SerializeIntoParentJson(Value, OutJsonObj);
	return Success;
}

bool FPragma_Inventory_ExtUpdateEntry::AddonDeserializer(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	bool Success = true;
	Success &= FPragma_Inventory_ExtUpdateEntry_Data::DeserializeFromParentJson(JsonObj, OutValue);
	return Success;
}

bool operator==(const FPragma_Inventory_ExtUpdateEntry& Lhs, const FPragma_Inventory_ExtUpdateEntry& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.Data == Rhs.Data
;
}
bool operator!=(const FPragma_Inventory_ExtUpdateEntry& Lhs, const FPragma_Inventory_ExtUpdateEntry& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_CookingCompleteSpec& Lhs, const FPragma_Inventory_CookingCompleteSpec& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.CatalogIdToCreate == Rhs.CatalogIdToCreate
;
}
bool operator!=(const FPragma_Inventory_CookingCompleteSpec& Lhs, const FPragma_Inventory_CookingCompleteSpec& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_CookingSpec& Lhs, const FPragma_Inventory_CookingSpec& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.CookTimeInSeconds == Rhs.CookTimeInSeconds
			&& Lhs.CatalogIdToCreate == Rhs.CatalogIdToCreate
;
}
bool operator!=(const FPragma_Inventory_CookingSpec& Lhs, const FPragma_Inventory_CookingSpec& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_PetEvolutionSpec& Lhs, const FPragma_Inventory_PetEvolutionSpec& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.TargetPetCatalogId == Rhs.TargetPetCatalogId
			&& Lhs.BonusIncrement == Rhs.BonusIncrement
;
}
bool operator!=(const FPragma_Inventory_PetEvolutionSpec& Lhs, const FPragma_Inventory_PetEvolutionSpec& Rhs)
{
	return !(Lhs == Rhs);
}

FPragma_Inventory_ExtCraftingEntry_Data::FPragma_Inventory_ExtCraftingEntry_Data() {}
FPragma_Inventory_ExtCraftingEntry_Data::~FPragma_Inventory_ExtCraftingEntry_Data()
{
	Reset();
}

FPragma_Inventory_ExtCraftingEntry_Data::FPragma_Inventory_ExtCraftingEntry_Data(const FPragma_Inventory_ExtCraftingEntry_Data& Other)
{
	*this = Other;
}

bool FPragma_Inventory_ExtCraftingEntry_Data::Equals(const FPragma_Inventory_ExtCraftingEntry_Data& Other) const
{
    if (OneOfType() != Other.OneOfType())
    {
        return false;
    }
	switch (OneOfType())
	{
	case EPragma_Inventory_ExtCraftingEntry_DataType::PetEvolutionSpec:
		return PetEvolutionSpec() == Other.PetEvolutionSpec();
	case EPragma_Inventory_ExtCraftingEntry_DataType::CookingSpec:
		return CookingSpec() == Other.CookingSpec();
	case EPragma_Inventory_ExtCraftingEntry_DataType::CookingCompleteSpec:
		return CookingCompleteSpec() == Other.CookingCompleteSpec();
	case EPragma_Inventory_ExtCraftingEntry_DataType::Invalid:
        return true;
	default:
		return false;
	}
}

FPragma_Inventory_ExtCraftingEntry_Data& FPragma_Inventory_ExtCraftingEntry_Data::operator=(const FPragma_Inventory_ExtCraftingEntry_Data& Other)
{
	Reset();
	Type = Other.OneOfType();
	switch (Other.OneOfType())
	{
	case EPragma_Inventory_ExtCraftingEntry_DataType::PetEvolutionSpec:
		new(Union.PetEvolutionSpec.GetTypedPtr()) FPragma_Inventory_PetEvolutionSpec(Other.PetEvolutionSpec());
		break;
	case EPragma_Inventory_ExtCraftingEntry_DataType::CookingSpec:
		new(Union.CookingSpec.GetTypedPtr()) FPragma_Inventory_CookingSpec(Other.CookingSpec());
		break;
	case EPragma_Inventory_ExtCraftingEntry_DataType::CookingCompleteSpec:
		new(Union.CookingCompleteSpec.GetTypedPtr()) FPragma_Inventory_CookingCompleteSpec(Other.CookingCompleteSpec());
		break;
	case EPragma_Inventory_ExtCraftingEntry_DataType::Invalid:
	default:
		break;
	}
	return *this;
}

void FPragma_Inventory_ExtCraftingEntry_Data::Reset()
{
	switch (OneOfType())
	{
	case EPragma_Inventory_ExtCraftingEntry_DataType::PetEvolutionSpec:
		Union.PetEvolutionSpec.GetTypedPtr()->~FPragma_Inventory_PetEvolutionSpec();
		break;
	case EPragma_Inventory_ExtCraftingEntry_DataType::CookingSpec:
		Union.CookingSpec.GetTypedPtr()->~FPragma_Inventory_CookingSpec();
		break;
	case EPragma_Inventory_ExtCraftingEntry_DataType::CookingCompleteSpec:
		Union.CookingCompleteSpec.GetTypedPtr()->~FPragma_Inventory_CookingCompleteSpec();
		break;
	case EPragma_Inventory_ExtCraftingEntry_DataType::Invalid:
	default:
		break;
	}
	Type = EPragma_Inventory_ExtCraftingEntry_DataType::Invalid;
}

const FPragma_Inventory_PetEvolutionSpec& FPragma_Inventory_ExtCraftingEntry_Data::PetEvolutionSpec() const {
	checkf(OneOfType() == EPragma_Inventory_ExtCraftingEntry_DataType::PetEvolutionSpec, TEXT("Failed to retrieve PetEvolutionSpec from FPragma_Inventory_ExtCraftingEntry_Data. Check the OneOfType() before accessing the value."));
	return *Union.PetEvolutionSpec.GetTypedPtr();
}
const FPragma_Inventory_CookingSpec& FPragma_Inventory_ExtCraftingEntry_Data::CookingSpec() const {
	checkf(OneOfType() == EPragma_Inventory_ExtCraftingEntry_DataType::CookingSpec, TEXT("Failed to retrieve CookingSpec from FPragma_Inventory_ExtCraftingEntry_Data. Check the OneOfType() before accessing the value."));
	return *Union.CookingSpec.GetTypedPtr();
}
const FPragma_Inventory_CookingCompleteSpec& FPragma_Inventory_ExtCraftingEntry_Data::CookingCompleteSpec() const {
	checkf(OneOfType() == EPragma_Inventory_ExtCraftingEntry_DataType::CookingCompleteSpec, TEXT("Failed to retrieve CookingCompleteSpec from FPragma_Inventory_ExtCraftingEntry_Data. Check the OneOfType() before accessing the value."));
	return *Union.CookingCompleteSpec.GetTypedPtr();
}

void FPragma_Inventory_ExtCraftingEntry_Data::SetPetEvolutionSpec(const FPragma_Inventory_PetEvolutionSpec& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtCraftingEntry_DataType::PetEvolutionSpec;
	new(Union.PetEvolutionSpec.GetTypedPtr()) FPragma_Inventory_PetEvolutionSpec(Value);
}
void FPragma_Inventory_ExtCraftingEntry_Data::SetCookingSpec(const FPragma_Inventory_CookingSpec& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtCraftingEntry_DataType::CookingSpec;
	new(Union.CookingSpec.GetTypedPtr()) FPragma_Inventory_CookingSpec(Value);
}
void FPragma_Inventory_ExtCraftingEntry_Data::SetCookingCompleteSpec(const FPragma_Inventory_CookingCompleteSpec& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtCraftingEntry_DataType::CookingCompleteSpec;
	new(Union.CookingCompleteSpec.GetTypedPtr()) FPragma_Inventory_CookingCompleteSpec(Value);
}

bool FPragma_Inventory_ExtCraftingEntry_Data::SerializeIntoParentJson(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	const FPragma_Inventory_ExtCraftingEntry_Data& OneOf = static_cast<const FPragma_Inventory_ExtCraftingEntry*>(Value)->Data;
	switch (OneOf.OneOfType())
	{
		case EPragma_Inventory_ExtCraftingEntry_DataType::PetEvolutionSpec:
			OutJsonObj->SetField("petEvolutionSpec", PragmaJson::StructToJsonValue(*OneOf.Union.PetEvolutionSpec.GetTypedPtr()));
			break;
		case EPragma_Inventory_ExtCraftingEntry_DataType::CookingSpec:
			OutJsonObj->SetField("cookingSpec", PragmaJson::StructToJsonValue(*OneOf.Union.CookingSpec.GetTypedPtr()));
			break;
		case EPragma_Inventory_ExtCraftingEntry_DataType::CookingCompleteSpec:
			OutJsonObj->SetField("cookingCompleteSpec", PragmaJson::StructToJsonValue(*OneOf.Union.CookingCompleteSpec.GetTypedPtr()));
			break;
		default:
			break;
	}
	// Per protobuf spec, it's ok to have empty oneof.
	return true;
}
bool FPragma_Inventory_ExtCraftingEntry_Data::DeserializeFromParentJson(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	FPragma_Inventory_ExtCraftingEntry_Data& OutOneOf = static_cast<FPragma_Inventory_ExtCraftingEntry*>(OutValue)->Data;
	if (JsonObj->HasField("petEvolutionSpec"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtCraftingEntry_DataType::PetEvolutionSpec;
		new(OutOneOf.Union.PetEvolutionSpec.GetTypedPtr()) FPragma_Inventory_PetEvolutionSpec(PragmaJson::JsonValueToStruct<FPragma_Inventory_PetEvolutionSpec>(JsonObj->TryGetField(TEXT("petEvolutionSpec")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	if (JsonObj->HasField("cookingSpec"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtCraftingEntry_DataType::CookingSpec;
		new(OutOneOf.Union.CookingSpec.GetTypedPtr()) FPragma_Inventory_CookingSpec(PragmaJson::JsonValueToStruct<FPragma_Inventory_CookingSpec>(JsonObj->TryGetField(TEXT("cookingSpec")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	if (JsonObj->HasField("cookingCompleteSpec"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtCraftingEntry_DataType::CookingCompleteSpec;
		new(OutOneOf.Union.CookingCompleteSpec.GetTypedPtr()) FPragma_Inventory_CookingCompleteSpec(PragmaJson::JsonValueToStruct<FPragma_Inventory_CookingCompleteSpec>(JsonObj->TryGetField(TEXT("cookingCompleteSpec")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	// Per protobuf spec, oneofs have _at most_ one of the fields. None set is valid, so we always return true.
	return true;
}

bool operator==(const FPragma_Inventory_ExtCraftingEntry_Data& Lhs, const FPragma_Inventory_ExtCraftingEntry_Data& Rhs)
{
	return Lhs.Equals(Rhs);
}
bool operator!=(const FPragma_Inventory_ExtCraftingEntry_Data& Lhs, const FPragma_Inventory_ExtCraftingEntry_Data& Rhs)
{
	return !(Lhs == Rhs);
}


bool FPragma_Inventory_ExtCraftingEntry::AddonSerializer(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	bool Success = true;
	Success &= FPragma_Inventory_ExtCraftingEntry_Data::SerializeIntoParentJson(Value, OutJsonObj);
	return Success;
}

bool FPragma_Inventory_ExtCraftingEntry::AddonDeserializer(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	bool Success = true;
	Success &= FPragma_Inventory_ExtCraftingEntry_Data::DeserializeFromParentJson(JsonObj, OutValue);
	return Success;
}

bool operator==(const FPragma_Inventory_ExtCraftingEntry& Lhs, const FPragma_Inventory_ExtCraftingEntry& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.Data == Rhs.Data
;
}
bool operator!=(const FPragma_Inventory_ExtCraftingEntry& Lhs, const FPragma_Inventory_ExtCraftingEntry& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_CookingCompleteRequirements& Lhs, const FPragma_Inventory_CookingCompleteRequirements& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.ConsumedCatalogId == Rhs.ConsumedCatalogId
;
}
bool operator!=(const FPragma_Inventory_CookingCompleteRequirements& Lhs, const FPragma_Inventory_CookingCompleteRequirements& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_PetEvolutionRequirements& Lhs, const FPragma_Inventory_PetEvolutionRequirements& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.RequiredPetCatalogId == Rhs.RequiredPetCatalogId
			&& Lhs.RequiredPlayerLocation == Rhs.RequiredPlayerLocation
;
}
bool operator!=(const FPragma_Inventory_PetEvolutionRequirements& Lhs, const FPragma_Inventory_PetEvolutionRequirements& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_MissionRequirements& Lhs, const FPragma_Inventory_MissionRequirements& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.Missions == Rhs.Missions
;
}
bool operator!=(const FPragma_Inventory_MissionRequirements& Lhs, const FPragma_Inventory_MissionRequirements& Rhs)
{
	return !(Lhs == Rhs);
}

FPragma_Inventory_ExtPurchaseRequirements_Data::FPragma_Inventory_ExtPurchaseRequirements_Data() {}
FPragma_Inventory_ExtPurchaseRequirements_Data::~FPragma_Inventory_ExtPurchaseRequirements_Data()
{
	Reset();
}

FPragma_Inventory_ExtPurchaseRequirements_Data::FPragma_Inventory_ExtPurchaseRequirements_Data(const FPragma_Inventory_ExtPurchaseRequirements_Data& Other)
{
	*this = Other;
}

bool FPragma_Inventory_ExtPurchaseRequirements_Data::Equals(const FPragma_Inventory_ExtPurchaseRequirements_Data& Other) const
{
    if (OneOfType() != Other.OneOfType())
    {
        return false;
    }
	switch (OneOfType())
	{
	case EPragma_Inventory_ExtPurchaseRequirements_DataType::MissionRequirements:
		return MissionRequirements() == Other.MissionRequirements();
	case EPragma_Inventory_ExtPurchaseRequirements_DataType::PetEvolutionRequirements:
		return PetEvolutionRequirements() == Other.PetEvolutionRequirements();
	case EPragma_Inventory_ExtPurchaseRequirements_DataType::CookingCompleteRequirements:
		return CookingCompleteRequirements() == Other.CookingCompleteRequirements();
	case EPragma_Inventory_ExtPurchaseRequirements_DataType::Invalid:
        return true;
	default:
		return false;
	}
}

FPragma_Inventory_ExtPurchaseRequirements_Data& FPragma_Inventory_ExtPurchaseRequirements_Data::operator=(const FPragma_Inventory_ExtPurchaseRequirements_Data& Other)
{
	Reset();
	Type = Other.OneOfType();
	switch (Other.OneOfType())
	{
	case EPragma_Inventory_ExtPurchaseRequirements_DataType::MissionRequirements:
		new(Union.MissionRequirements.GetTypedPtr()) FPragma_Inventory_MissionRequirements(Other.MissionRequirements());
		break;
	case EPragma_Inventory_ExtPurchaseRequirements_DataType::PetEvolutionRequirements:
		new(Union.PetEvolutionRequirements.GetTypedPtr()) FPragma_Inventory_PetEvolutionRequirements(Other.PetEvolutionRequirements());
		break;
	case EPragma_Inventory_ExtPurchaseRequirements_DataType::CookingCompleteRequirements:
		new(Union.CookingCompleteRequirements.GetTypedPtr()) FPragma_Inventory_CookingCompleteRequirements(Other.CookingCompleteRequirements());
		break;
	case EPragma_Inventory_ExtPurchaseRequirements_DataType::Invalid:
	default:
		break;
	}
	return *this;
}

void FPragma_Inventory_ExtPurchaseRequirements_Data::Reset()
{
	switch (OneOfType())
	{
	case EPragma_Inventory_ExtPurchaseRequirements_DataType::MissionRequirements:
		Union.MissionRequirements.GetTypedPtr()->~FPragma_Inventory_MissionRequirements();
		break;
	case EPragma_Inventory_ExtPurchaseRequirements_DataType::PetEvolutionRequirements:
		Union.PetEvolutionRequirements.GetTypedPtr()->~FPragma_Inventory_PetEvolutionRequirements();
		break;
	case EPragma_Inventory_ExtPurchaseRequirements_DataType::CookingCompleteRequirements:
		Union.CookingCompleteRequirements.GetTypedPtr()->~FPragma_Inventory_CookingCompleteRequirements();
		break;
	case EPragma_Inventory_ExtPurchaseRequirements_DataType::Invalid:
	default:
		break;
	}
	Type = EPragma_Inventory_ExtPurchaseRequirements_DataType::Invalid;
}

const FPragma_Inventory_MissionRequirements& FPragma_Inventory_ExtPurchaseRequirements_Data::MissionRequirements() const {
	checkf(OneOfType() == EPragma_Inventory_ExtPurchaseRequirements_DataType::MissionRequirements, TEXT("Failed to retrieve MissionRequirements from FPragma_Inventory_ExtPurchaseRequirements_Data. Check the OneOfType() before accessing the value."));
	return *Union.MissionRequirements.GetTypedPtr();
}
const FPragma_Inventory_PetEvolutionRequirements& FPragma_Inventory_ExtPurchaseRequirements_Data::PetEvolutionRequirements() const {
	checkf(OneOfType() == EPragma_Inventory_ExtPurchaseRequirements_DataType::PetEvolutionRequirements, TEXT("Failed to retrieve PetEvolutionRequirements from FPragma_Inventory_ExtPurchaseRequirements_Data. Check the OneOfType() before accessing the value."));
	return *Union.PetEvolutionRequirements.GetTypedPtr();
}
const FPragma_Inventory_CookingCompleteRequirements& FPragma_Inventory_ExtPurchaseRequirements_Data::CookingCompleteRequirements() const {
	checkf(OneOfType() == EPragma_Inventory_ExtPurchaseRequirements_DataType::CookingCompleteRequirements, TEXT("Failed to retrieve CookingCompleteRequirements from FPragma_Inventory_ExtPurchaseRequirements_Data. Check the OneOfType() before accessing the value."));
	return *Union.CookingCompleteRequirements.GetTypedPtr();
}

void FPragma_Inventory_ExtPurchaseRequirements_Data::SetMissionRequirements(const FPragma_Inventory_MissionRequirements& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtPurchaseRequirements_DataType::MissionRequirements;
	new(Union.MissionRequirements.GetTypedPtr()) FPragma_Inventory_MissionRequirements(Value);
}
void FPragma_Inventory_ExtPurchaseRequirements_Data::SetPetEvolutionRequirements(const FPragma_Inventory_PetEvolutionRequirements& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtPurchaseRequirements_DataType::PetEvolutionRequirements;
	new(Union.PetEvolutionRequirements.GetTypedPtr()) FPragma_Inventory_PetEvolutionRequirements(Value);
}
void FPragma_Inventory_ExtPurchaseRequirements_Data::SetCookingCompleteRequirements(const FPragma_Inventory_CookingCompleteRequirements& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtPurchaseRequirements_DataType::CookingCompleteRequirements;
	new(Union.CookingCompleteRequirements.GetTypedPtr()) FPragma_Inventory_CookingCompleteRequirements(Value);
}

bool FPragma_Inventory_ExtPurchaseRequirements_Data::SerializeIntoParentJson(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	const FPragma_Inventory_ExtPurchaseRequirements_Data& OneOf = static_cast<const FPragma_Inventory_ExtPurchaseRequirements*>(Value)->Data;
	switch (OneOf.OneOfType())
	{
		case EPragma_Inventory_ExtPurchaseRequirements_DataType::MissionRequirements:
			OutJsonObj->SetField("missionRequirements", PragmaJson::StructToJsonValue(*OneOf.Union.MissionRequirements.GetTypedPtr()));
			break;
		case EPragma_Inventory_ExtPurchaseRequirements_DataType::PetEvolutionRequirements:
			OutJsonObj->SetField("petEvolutionRequirements", PragmaJson::StructToJsonValue(*OneOf.Union.PetEvolutionRequirements.GetTypedPtr()));
			break;
		case EPragma_Inventory_ExtPurchaseRequirements_DataType::CookingCompleteRequirements:
			OutJsonObj->SetField("cookingCompleteRequirements", PragmaJson::StructToJsonValue(*OneOf.Union.CookingCompleteRequirements.GetTypedPtr()));
			break;
		default:
			break;
	}
	// Per protobuf spec, it's ok to have empty oneof.
	return true;
}
bool FPragma_Inventory_ExtPurchaseRequirements_Data::DeserializeFromParentJson(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	FPragma_Inventory_ExtPurchaseRequirements_Data& OutOneOf = static_cast<FPragma_Inventory_ExtPurchaseRequirements*>(OutValue)->Data;
	if (JsonObj->HasField("missionRequirements"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtPurchaseRequirements_DataType::MissionRequirements;
		new(OutOneOf.Union.MissionRequirements.GetTypedPtr()) FPragma_Inventory_MissionRequirements(PragmaJson::JsonValueToStruct<FPragma_Inventory_MissionRequirements>(JsonObj->TryGetField(TEXT("missionRequirements")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	if (JsonObj->HasField("petEvolutionRequirements"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtPurchaseRequirements_DataType::PetEvolutionRequirements;
		new(OutOneOf.Union.PetEvolutionRequirements.GetTypedPtr()) FPragma_Inventory_PetEvolutionRequirements(PragmaJson::JsonValueToStruct<FPragma_Inventory_PetEvolutionRequirements>(JsonObj->TryGetField(TEXT("petEvolutionRequirements")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	if (JsonObj->HasField("cookingCompleteRequirements"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtPurchaseRequirements_DataType::CookingCompleteRequirements;
		new(OutOneOf.Union.CookingCompleteRequirements.GetTypedPtr()) FPragma_Inventory_CookingCompleteRequirements(PragmaJson::JsonValueToStruct<FPragma_Inventory_CookingCompleteRequirements>(JsonObj->TryGetField(TEXT("cookingCompleteRequirements")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	// Per protobuf spec, oneofs have _at most_ one of the fields. None set is valid, so we always return true.
	return true;
}

bool operator==(const FPragma_Inventory_ExtPurchaseRequirements_Data& Lhs, const FPragma_Inventory_ExtPurchaseRequirements_Data& Rhs)
{
	return Lhs.Equals(Rhs);
}
bool operator!=(const FPragma_Inventory_ExtPurchaseRequirements_Data& Lhs, const FPragma_Inventory_ExtPurchaseRequirements_Data& Rhs)
{
	return !(Lhs == Rhs);
}


bool FPragma_Inventory_ExtPurchaseRequirements::AddonSerializer(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	bool Success = true;
	Success &= FPragma_Inventory_ExtPurchaseRequirements_Data::SerializeIntoParentJson(Value, OutJsonObj);
	return Success;
}

bool FPragma_Inventory_ExtPurchaseRequirements::AddonDeserializer(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	bool Success = true;
	Success &= FPragma_Inventory_ExtPurchaseRequirements_Data::DeserializeFromParentJson(JsonObj, OutValue);
	return Success;
}

bool operator==(const FPragma_Inventory_ExtPurchaseRequirements& Lhs, const FPragma_Inventory_ExtPurchaseRequirements& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.Data == Rhs.Data
;
}
bool operator!=(const FPragma_Inventory_ExtPurchaseRequirements& Lhs, const FPragma_Inventory_ExtPurchaseRequirements& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_ExtStackableSpec& Lhs, const FPragma_Inventory_ExtStackableSpec& Rhs)
{
	return true // Initial true allows simpler codegen.
;
}
bool operator!=(const FPragma_Inventory_ExtStackableSpec& Lhs, const FPragma_Inventory_ExtStackableSpec& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_TrackingSpec& Lhs, const FPragma_Inventory_TrackingSpec& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.Max == Rhs.Max
;
}
bool operator!=(const FPragma_Inventory_TrackingSpec& Lhs, const FPragma_Inventory_TrackingSpec& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_GearSpec& Lhs, const FPragma_Inventory_GearSpec& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.BonusTableSpecId == Rhs.BonusTableSpecId
;
}
bool operator!=(const FPragma_Inventory_GearSpec& Lhs, const FPragma_Inventory_GearSpec& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_MissionsSpec& Lhs, const FPragma_Inventory_MissionsSpec& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.MissionsById.OrderIndependentCompareEqual(Rhs.MissionsById)
;
}
bool operator!=(const FPragma_Inventory_MissionsSpec& Lhs, const FPragma_Inventory_MissionsSpec& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_IncompleteFoodSpec& Lhs, const FPragma_Inventory_IncompleteFoodSpec& Rhs)
{
	return true // Initial true allows simpler codegen.
;
}
bool operator!=(const FPragma_Inventory_IncompleteFoodSpec& Lhs, const FPragma_Inventory_IncompleteFoodSpec& Rhs)
{
	return !(Lhs == Rhs);
}

FPragma_Inventory_ExtInstancedSpec_Data::FPragma_Inventory_ExtInstancedSpec_Data() {}
FPragma_Inventory_ExtInstancedSpec_Data::~FPragma_Inventory_ExtInstancedSpec_Data()
{
	Reset();
}

FPragma_Inventory_ExtInstancedSpec_Data::FPragma_Inventory_ExtInstancedSpec_Data(const FPragma_Inventory_ExtInstancedSpec_Data& Other)
{
	*this = Other;
}

bool FPragma_Inventory_ExtInstancedSpec_Data::Equals(const FPragma_Inventory_ExtInstancedSpec_Data& Other) const
{
    if (OneOfType() != Other.OneOfType())
    {
        return false;
    }
	switch (OneOfType())
	{
	case EPragma_Inventory_ExtInstancedSpec_DataType::PetSpec:
		return PetSpec() == Other.PetSpec();
	case EPragma_Inventory_ExtInstancedSpec_DataType::IncompleteFoodSpec:
		return IncompleteFoodSpec() == Other.IncompleteFoodSpec();
	case EPragma_Inventory_ExtInstancedSpec_DataType::MissionsSpec:
		return MissionsSpec() == Other.MissionsSpec();
	case EPragma_Inventory_ExtInstancedSpec_DataType::GearSpec:
		return GearSpec() == Other.GearSpec();
	case EPragma_Inventory_ExtInstancedSpec_DataType::TrackingSpec:
		return TrackingSpec() == Other.TrackingSpec();
	case EPragma_Inventory_ExtInstancedSpec_DataType::Invalid:
        return true;
	default:
		return false;
	}
}

FPragma_Inventory_ExtInstancedSpec_Data& FPragma_Inventory_ExtInstancedSpec_Data::operator=(const FPragma_Inventory_ExtInstancedSpec_Data& Other)
{
	Reset();
	Type = Other.OneOfType();
	switch (Other.OneOfType())
	{
	case EPragma_Inventory_ExtInstancedSpec_DataType::PetSpec:
		new(Union.PetSpec.GetTypedPtr()) FPragma_Inventory_PetSpec(Other.PetSpec());
		break;
	case EPragma_Inventory_ExtInstancedSpec_DataType::IncompleteFoodSpec:
		new(Union.IncompleteFoodSpec.GetTypedPtr()) FPragma_Inventory_IncompleteFoodSpec(Other.IncompleteFoodSpec());
		break;
	case EPragma_Inventory_ExtInstancedSpec_DataType::MissionsSpec:
		new(Union.MissionsSpec.GetTypedPtr()) FPragma_Inventory_MissionsSpec(Other.MissionsSpec());
		break;
	case EPragma_Inventory_ExtInstancedSpec_DataType::GearSpec:
		new(Union.GearSpec.GetTypedPtr()) FPragma_Inventory_GearSpec(Other.GearSpec());
		break;
	case EPragma_Inventory_ExtInstancedSpec_DataType::TrackingSpec:
		new(Union.TrackingSpec.GetTypedPtr()) FPragma_Inventory_TrackingSpec(Other.TrackingSpec());
		break;
	case EPragma_Inventory_ExtInstancedSpec_DataType::Invalid:
	default:
		break;
	}
	return *this;
}

void FPragma_Inventory_ExtInstancedSpec_Data::Reset()
{
	switch (OneOfType())
	{
	case EPragma_Inventory_ExtInstancedSpec_DataType::PetSpec:
		Union.PetSpec.GetTypedPtr()->~FPragma_Inventory_PetSpec();
		break;
	case EPragma_Inventory_ExtInstancedSpec_DataType::IncompleteFoodSpec:
		Union.IncompleteFoodSpec.GetTypedPtr()->~FPragma_Inventory_IncompleteFoodSpec();
		break;
	case EPragma_Inventory_ExtInstancedSpec_DataType::MissionsSpec:
		Union.MissionsSpec.GetTypedPtr()->~FPragma_Inventory_MissionsSpec();
		break;
	case EPragma_Inventory_ExtInstancedSpec_DataType::GearSpec:
		Union.GearSpec.GetTypedPtr()->~FPragma_Inventory_GearSpec();
		break;
	case EPragma_Inventory_ExtInstancedSpec_DataType::TrackingSpec:
		Union.TrackingSpec.GetTypedPtr()->~FPragma_Inventory_TrackingSpec();
		break;
	case EPragma_Inventory_ExtInstancedSpec_DataType::Invalid:
	default:
		break;
	}
	Type = EPragma_Inventory_ExtInstancedSpec_DataType::Invalid;
}

const FPragma_Inventory_PetSpec& FPragma_Inventory_ExtInstancedSpec_Data::PetSpec() const {
	checkf(OneOfType() == EPragma_Inventory_ExtInstancedSpec_DataType::PetSpec, TEXT("Failed to retrieve PetSpec from FPragma_Inventory_ExtInstancedSpec_Data. Check the OneOfType() before accessing the value."));
	return *Union.PetSpec.GetTypedPtr();
}
const FPragma_Inventory_IncompleteFoodSpec& FPragma_Inventory_ExtInstancedSpec_Data::IncompleteFoodSpec() const {
	checkf(OneOfType() == EPragma_Inventory_ExtInstancedSpec_DataType::IncompleteFoodSpec, TEXT("Failed to retrieve IncompleteFoodSpec from FPragma_Inventory_ExtInstancedSpec_Data. Check the OneOfType() before accessing the value."));
	return *Union.IncompleteFoodSpec.GetTypedPtr();
}
const FPragma_Inventory_MissionsSpec& FPragma_Inventory_ExtInstancedSpec_Data::MissionsSpec() const {
	checkf(OneOfType() == EPragma_Inventory_ExtInstancedSpec_DataType::MissionsSpec, TEXT("Failed to retrieve MissionsSpec from FPragma_Inventory_ExtInstancedSpec_Data. Check the OneOfType() before accessing the value."));
	return *Union.MissionsSpec.GetTypedPtr();
}
const FPragma_Inventory_GearSpec& FPragma_Inventory_ExtInstancedSpec_Data::GearSpec() const {
	checkf(OneOfType() == EPragma_Inventory_ExtInstancedSpec_DataType::GearSpec, TEXT("Failed to retrieve GearSpec from FPragma_Inventory_ExtInstancedSpec_Data. Check the OneOfType() before accessing the value."));
	return *Union.GearSpec.GetTypedPtr();
}
const FPragma_Inventory_TrackingSpec& FPragma_Inventory_ExtInstancedSpec_Data::TrackingSpec() const {
	checkf(OneOfType() == EPragma_Inventory_ExtInstancedSpec_DataType::TrackingSpec, TEXT("Failed to retrieve TrackingSpec from FPragma_Inventory_ExtInstancedSpec_Data. Check the OneOfType() before accessing the value."));
	return *Union.TrackingSpec.GetTypedPtr();
}

void FPragma_Inventory_ExtInstancedSpec_Data::SetPetSpec(const FPragma_Inventory_PetSpec& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtInstancedSpec_DataType::PetSpec;
	new(Union.PetSpec.GetTypedPtr()) FPragma_Inventory_PetSpec(Value);
}
void FPragma_Inventory_ExtInstancedSpec_Data::SetIncompleteFoodSpec(const FPragma_Inventory_IncompleteFoodSpec& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtInstancedSpec_DataType::IncompleteFoodSpec;
	new(Union.IncompleteFoodSpec.GetTypedPtr()) FPragma_Inventory_IncompleteFoodSpec(Value);
}
void FPragma_Inventory_ExtInstancedSpec_Data::SetMissionsSpec(const FPragma_Inventory_MissionsSpec& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtInstancedSpec_DataType::MissionsSpec;
	new(Union.MissionsSpec.GetTypedPtr()) FPragma_Inventory_MissionsSpec(Value);
}
void FPragma_Inventory_ExtInstancedSpec_Data::SetGearSpec(const FPragma_Inventory_GearSpec& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtInstancedSpec_DataType::GearSpec;
	new(Union.GearSpec.GetTypedPtr()) FPragma_Inventory_GearSpec(Value);
}
void FPragma_Inventory_ExtInstancedSpec_Data::SetTrackingSpec(const FPragma_Inventory_TrackingSpec& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtInstancedSpec_DataType::TrackingSpec;
	new(Union.TrackingSpec.GetTypedPtr()) FPragma_Inventory_TrackingSpec(Value);
}

bool FPragma_Inventory_ExtInstancedSpec_Data::SerializeIntoParentJson(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	const FPragma_Inventory_ExtInstancedSpec_Data& OneOf = static_cast<const FPragma_Inventory_ExtInstancedSpec*>(Value)->Data;
	switch (OneOf.OneOfType())
	{
		case EPragma_Inventory_ExtInstancedSpec_DataType::PetSpec:
			OutJsonObj->SetField("petSpec", PragmaJson::StructToJsonValue(*OneOf.Union.PetSpec.GetTypedPtr()));
			break;
		case EPragma_Inventory_ExtInstancedSpec_DataType::IncompleteFoodSpec:
			OutJsonObj->SetField("incompleteFoodSpec", PragmaJson::StructToJsonValue(*OneOf.Union.IncompleteFoodSpec.GetTypedPtr()));
			break;
		case EPragma_Inventory_ExtInstancedSpec_DataType::MissionsSpec:
			OutJsonObj->SetField("missionsSpec", PragmaJson::StructToJsonValue(*OneOf.Union.MissionsSpec.GetTypedPtr()));
			break;
		case EPragma_Inventory_ExtInstancedSpec_DataType::GearSpec:
			OutJsonObj->SetField("gearSpec", PragmaJson::StructToJsonValue(*OneOf.Union.GearSpec.GetTypedPtr()));
			break;
		case EPragma_Inventory_ExtInstancedSpec_DataType::TrackingSpec:
			OutJsonObj->SetField("trackingSpec", PragmaJson::StructToJsonValue(*OneOf.Union.TrackingSpec.GetTypedPtr()));
			break;
		default:
			break;
	}
	// Per protobuf spec, it's ok to have empty oneof.
	return true;
}
bool FPragma_Inventory_ExtInstancedSpec_Data::DeserializeFromParentJson(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	FPragma_Inventory_ExtInstancedSpec_Data& OutOneOf = static_cast<FPragma_Inventory_ExtInstancedSpec*>(OutValue)->Data;
	if (JsonObj->HasField("petSpec"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtInstancedSpec_DataType::PetSpec;
		new(OutOneOf.Union.PetSpec.GetTypedPtr()) FPragma_Inventory_PetSpec(PragmaJson::JsonValueToStruct<FPragma_Inventory_PetSpec>(JsonObj->TryGetField(TEXT("petSpec")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	if (JsonObj->HasField("incompleteFoodSpec"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtInstancedSpec_DataType::IncompleteFoodSpec;
		new(OutOneOf.Union.IncompleteFoodSpec.GetTypedPtr()) FPragma_Inventory_IncompleteFoodSpec(PragmaJson::JsonValueToStruct<FPragma_Inventory_IncompleteFoodSpec>(JsonObj->TryGetField(TEXT("incompleteFoodSpec")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	if (JsonObj->HasField("missionsSpec"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtInstancedSpec_DataType::MissionsSpec;
		new(OutOneOf.Union.MissionsSpec.GetTypedPtr()) FPragma_Inventory_MissionsSpec(PragmaJson::JsonValueToStruct<FPragma_Inventory_MissionsSpec>(JsonObj->TryGetField(TEXT("missionsSpec")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	if (JsonObj->HasField("gearSpec"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtInstancedSpec_DataType::GearSpec;
		new(OutOneOf.Union.GearSpec.GetTypedPtr()) FPragma_Inventory_GearSpec(PragmaJson::JsonValueToStruct<FPragma_Inventory_GearSpec>(JsonObj->TryGetField(TEXT("gearSpec")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	if (JsonObj->HasField("trackingSpec"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtInstancedSpec_DataType::TrackingSpec;
		new(OutOneOf.Union.TrackingSpec.GetTypedPtr()) FPragma_Inventory_TrackingSpec(PragmaJson::JsonValueToStruct<FPragma_Inventory_TrackingSpec>(JsonObj->TryGetField(TEXT("trackingSpec")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	// Per protobuf spec, oneofs have _at most_ one of the fields. None set is valid, so we always return true.
	return true;
}

bool operator==(const FPragma_Inventory_ExtInstancedSpec_Data& Lhs, const FPragma_Inventory_ExtInstancedSpec_Data& Rhs)
{
	return Lhs.Equals(Rhs);
}
bool operator!=(const FPragma_Inventory_ExtInstancedSpec_Data& Lhs, const FPragma_Inventory_ExtInstancedSpec_Data& Rhs)
{
	return !(Lhs == Rhs);
}


bool FPragma_Inventory_ExtInstancedSpec::AddonSerializer(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	bool Success = true;
	Success &= FPragma_Inventory_ExtInstancedSpec_Data::SerializeIntoParentJson(Value, OutJsonObj);
	return Success;
}

bool FPragma_Inventory_ExtInstancedSpec::AddonDeserializer(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	bool Success = true;
	Success &= FPragma_Inventory_ExtInstancedSpec_Data::DeserializeFromParentJson(JsonObj, OutValue);
	return Success;
}

bool operator==(const FPragma_Inventory_ExtInstancedSpec& Lhs, const FPragma_Inventory_ExtInstancedSpec& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.Data == Rhs.Data
;
}
bool operator!=(const FPragma_Inventory_ExtInstancedSpec& Lhs, const FPragma_Inventory_ExtInstancedSpec& Rhs)
{
	return !(Lhs == Rhs);
}
