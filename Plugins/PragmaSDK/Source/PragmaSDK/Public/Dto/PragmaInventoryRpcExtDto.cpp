// <auto-generated>
//      Generated by Pragma Platform protoc-custom-plugins sdk-unreal4 target.  DO NOT EDIT!
//      Source template: unreal4/Dto.cpp.mustache
// </auto-generated>

#include "PragmaInventoryRpcExtDto.h"
#include "CoreMinimal.h"
#include "PragmaJson.h"


FPragma_Inventory_ExtCraftRequest_Data::FPragma_Inventory_ExtCraftRequest_Data() {}
FPragma_Inventory_ExtCraftRequest_Data::~FPragma_Inventory_ExtCraftRequest_Data()
{
	Reset();
}

FPragma_Inventory_ExtCraftRequest_Data::FPragma_Inventory_ExtCraftRequest_Data(const FPragma_Inventory_ExtCraftRequest_Data& Other)
{
	*this = Other;
}

bool FPragma_Inventory_ExtCraftRequest_Data::Equals(const FPragma_Inventory_ExtCraftRequest_Data& Other) const
{
    if (OneOfType() != Other.OneOfType())
    {
        return false;
    }
	switch (OneOfType())
	{
	case EPragma_Inventory_ExtCraftRequest_DataType::PetEvolutionRequest:
		return PetEvolutionRequest() == Other.PetEvolutionRequest();
	case EPragma_Inventory_ExtCraftRequest_DataType::Invalid:
        return true;
	default:
		return false;
	}
}

FPragma_Inventory_ExtCraftRequest_Data& FPragma_Inventory_ExtCraftRequest_Data::operator=(const FPragma_Inventory_ExtCraftRequest_Data& Other)
{
	Reset();
	Type = Other.OneOfType();
	switch (Other.OneOfType())
	{
	case EPragma_Inventory_ExtCraftRequest_DataType::PetEvolutionRequest:
		new(Union.PetEvolutionRequest.GetTypedPtr()) FPragma_Inventory_PetEvolutionRequest(Other.PetEvolutionRequest());
		break;
	case EPragma_Inventory_ExtCraftRequest_DataType::Invalid:
	default:
		break;
	}
	return *this;
}

void FPragma_Inventory_ExtCraftRequest_Data::Reset()
{
	switch (OneOfType())
	{
	case EPragma_Inventory_ExtCraftRequest_DataType::PetEvolutionRequest:
		Union.PetEvolutionRequest.GetTypedPtr()->~FPragma_Inventory_PetEvolutionRequest();
		break;
	case EPragma_Inventory_ExtCraftRequest_DataType::Invalid:
	default:
		break;
	}
	Type = EPragma_Inventory_ExtCraftRequest_DataType::Invalid;
}

const FPragma_Inventory_PetEvolutionRequest& FPragma_Inventory_ExtCraftRequest_Data::PetEvolutionRequest() const {
	checkf(OneOfType() == EPragma_Inventory_ExtCraftRequest_DataType::PetEvolutionRequest, TEXT("Failed to retrieve PetEvolutionRequest from FPragma_Inventory_ExtCraftRequest_Data. Check the OneOfType() before accessing the value."));
	return *Union.PetEvolutionRequest.GetTypedPtr();
}

void FPragma_Inventory_ExtCraftRequest_Data::SetPetEvolutionRequest(const FPragma_Inventory_PetEvolutionRequest& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtCraftRequest_DataType::PetEvolutionRequest;
	new(Union.PetEvolutionRequest.GetTypedPtr()) FPragma_Inventory_PetEvolutionRequest(Value);
}

bool FPragma_Inventory_ExtCraftRequest_Data::SerializeIntoParentJson(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	const FPragma_Inventory_ExtCraftRequest_Data& OneOf = static_cast<const FPragma_Inventory_ExtCraftRequest*>(Value)->Data;
	switch (OneOf.OneOfType())
	{
		case EPragma_Inventory_ExtCraftRequest_DataType::PetEvolutionRequest:
			OutJsonObj->SetField("petEvolutionRequest", PragmaJson::StructToJsonValue(*OneOf.Union.PetEvolutionRequest.GetTypedPtr()));
			break;
		default:
			break;
	}
	// Per protobuf spec, it's ok to have empty oneof.
	return true;
}
bool FPragma_Inventory_ExtCraftRequest_Data::DeserializeFromParentJson(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	FPragma_Inventory_ExtCraftRequest_Data& OutOneOf = static_cast<FPragma_Inventory_ExtCraftRequest*>(OutValue)->Data;
	if (JsonObj->HasField("petEvolutionRequest"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtCraftRequest_DataType::PetEvolutionRequest;
		new(OutOneOf.Union.PetEvolutionRequest.GetTypedPtr()) FPragma_Inventory_PetEvolutionRequest(PragmaJson::JsonValueToStruct<FPragma_Inventory_PetEvolutionRequest>(JsonObj->TryGetField(TEXT("petEvolutionRequest")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	// Per protobuf spec, oneofs have _at most_ one of the fields. None set is valid, so we always return true.
	return true;
}

bool operator==(const FPragma_Inventory_ExtCraftRequest_Data& Lhs, const FPragma_Inventory_ExtCraftRequest_Data& Rhs)
{
	return Lhs.Equals(Rhs);
}
bool operator!=(const FPragma_Inventory_ExtCraftRequest_Data& Lhs, const FPragma_Inventory_ExtCraftRequest_Data& Rhs)
{
	return !(Lhs == Rhs);
}


bool FPragma_Inventory_ExtCraftRequest::AddonSerializer(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	bool Success = true;
	Success &= FPragma_Inventory_ExtCraftRequest_Data::SerializeIntoParentJson(Value, OutJsonObj);
	return Success;
}

bool FPragma_Inventory_ExtCraftRequest::AddonDeserializer(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	bool Success = true;
	Success &= FPragma_Inventory_ExtCraftRequest_Data::DeserializeFromParentJson(JsonObj, OutValue);
	return Success;
}

bool operator==(const FPragma_Inventory_ExtCraftRequest& Lhs, const FPragma_Inventory_ExtCraftRequest& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.Data == Rhs.Data
;
}
bool operator!=(const FPragma_Inventory_ExtCraftRequest& Lhs, const FPragma_Inventory_ExtCraftRequest& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_TrackingItemUpdate& Lhs, const FPragma_Inventory_TrackingItemUpdate& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.InstanceIdToTrack == Rhs.InstanceIdToTrack
			&& Lhs.CatalogIdToTrack == Rhs.CatalogIdToTrack
;
}
bool operator!=(const FPragma_Inventory_TrackingItemUpdate& Lhs, const FPragma_Inventory_TrackingItemUpdate& Rhs)
{
	return !(Lhs == Rhs);
}

FPragma_Inventory_ExtInstancedItemServerUpdate_Data::FPragma_Inventory_ExtInstancedItemServerUpdate_Data() {}
FPragma_Inventory_ExtInstancedItemServerUpdate_Data::~FPragma_Inventory_ExtInstancedItemServerUpdate_Data()
{
	Reset();
}

FPragma_Inventory_ExtInstancedItemServerUpdate_Data::FPragma_Inventory_ExtInstancedItemServerUpdate_Data(const FPragma_Inventory_ExtInstancedItemServerUpdate_Data& Other)
{
	*this = Other;
}

bool FPragma_Inventory_ExtInstancedItemServerUpdate_Data::Equals(const FPragma_Inventory_ExtInstancedItemServerUpdate_Data& Other) const
{
    if (OneOfType() != Other.OneOfType())
    {
        return false;
    }
	switch (OneOfType())
	{
	case EPragma_Inventory_ExtInstancedItemServerUpdate_DataType::ActiveMissionsUpdate:
		return ActiveMissionsUpdate() == Other.ActiveMissionsUpdate();
	case EPragma_Inventory_ExtInstancedItemServerUpdate_DataType::PetUpdate:
		return PetUpdate() == Other.PetUpdate();
	case EPragma_Inventory_ExtInstancedItemServerUpdate_DataType::TrackingItemUpdate:
		return TrackingItemUpdate() == Other.TrackingItemUpdate();
	case EPragma_Inventory_ExtInstancedItemServerUpdate_DataType::Invalid:
        return true;
	default:
		return false;
	}
}

FPragma_Inventory_ExtInstancedItemServerUpdate_Data& FPragma_Inventory_ExtInstancedItemServerUpdate_Data::operator=(const FPragma_Inventory_ExtInstancedItemServerUpdate_Data& Other)
{
	Reset();
	Type = Other.OneOfType();
	switch (Other.OneOfType())
	{
	case EPragma_Inventory_ExtInstancedItemServerUpdate_DataType::ActiveMissionsUpdate:
		new(Union.ActiveMissionsUpdate.GetTypedPtr()) FPragma_Ext_ActiveMissionsUpdate(Other.ActiveMissionsUpdate());
		break;
	case EPragma_Inventory_ExtInstancedItemServerUpdate_DataType::PetUpdate:
		new(Union.PetUpdate.GetTypedPtr()) FPragma_Inventory_PetUpdate(Other.PetUpdate());
		break;
	case EPragma_Inventory_ExtInstancedItemServerUpdate_DataType::TrackingItemUpdate:
		new(Union.TrackingItemUpdate.GetTypedPtr()) FPragma_Inventory_TrackingItemUpdate(Other.TrackingItemUpdate());
		break;
	case EPragma_Inventory_ExtInstancedItemServerUpdate_DataType::Invalid:
	default:
		break;
	}
	return *this;
}

void FPragma_Inventory_ExtInstancedItemServerUpdate_Data::Reset()
{
	switch (OneOfType())
	{
	case EPragma_Inventory_ExtInstancedItemServerUpdate_DataType::ActiveMissionsUpdate:
		Union.ActiveMissionsUpdate.GetTypedPtr()->~FPragma_Ext_ActiveMissionsUpdate();
		break;
	case EPragma_Inventory_ExtInstancedItemServerUpdate_DataType::PetUpdate:
		Union.PetUpdate.GetTypedPtr()->~FPragma_Inventory_PetUpdate();
		break;
	case EPragma_Inventory_ExtInstancedItemServerUpdate_DataType::TrackingItemUpdate:
		Union.TrackingItemUpdate.GetTypedPtr()->~FPragma_Inventory_TrackingItemUpdate();
		break;
	case EPragma_Inventory_ExtInstancedItemServerUpdate_DataType::Invalid:
	default:
		break;
	}
	Type = EPragma_Inventory_ExtInstancedItemServerUpdate_DataType::Invalid;
}

const FPragma_Ext_ActiveMissionsUpdate& FPragma_Inventory_ExtInstancedItemServerUpdate_Data::ActiveMissionsUpdate() const {
	checkf(OneOfType() == EPragma_Inventory_ExtInstancedItemServerUpdate_DataType::ActiveMissionsUpdate, TEXT("Failed to retrieve ActiveMissionsUpdate from FPragma_Inventory_ExtInstancedItemServerUpdate_Data. Check the OneOfType() before accessing the value."));
	return *Union.ActiveMissionsUpdate.GetTypedPtr();
}
const FPragma_Inventory_PetUpdate& FPragma_Inventory_ExtInstancedItemServerUpdate_Data::PetUpdate() const {
	checkf(OneOfType() == EPragma_Inventory_ExtInstancedItemServerUpdate_DataType::PetUpdate, TEXT("Failed to retrieve PetUpdate from FPragma_Inventory_ExtInstancedItemServerUpdate_Data. Check the OneOfType() before accessing the value."));
	return *Union.PetUpdate.GetTypedPtr();
}
const FPragma_Inventory_TrackingItemUpdate& FPragma_Inventory_ExtInstancedItemServerUpdate_Data::TrackingItemUpdate() const {
	checkf(OneOfType() == EPragma_Inventory_ExtInstancedItemServerUpdate_DataType::TrackingItemUpdate, TEXT("Failed to retrieve TrackingItemUpdate from FPragma_Inventory_ExtInstancedItemServerUpdate_Data. Check the OneOfType() before accessing the value."));
	return *Union.TrackingItemUpdate.GetTypedPtr();
}

void FPragma_Inventory_ExtInstancedItemServerUpdate_Data::SetActiveMissionsUpdate(const FPragma_Ext_ActiveMissionsUpdate& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtInstancedItemServerUpdate_DataType::ActiveMissionsUpdate;
	new(Union.ActiveMissionsUpdate.GetTypedPtr()) FPragma_Ext_ActiveMissionsUpdate(Value);
}
void FPragma_Inventory_ExtInstancedItemServerUpdate_Data::SetPetUpdate(const FPragma_Inventory_PetUpdate& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtInstancedItemServerUpdate_DataType::PetUpdate;
	new(Union.PetUpdate.GetTypedPtr()) FPragma_Inventory_PetUpdate(Value);
}
void FPragma_Inventory_ExtInstancedItemServerUpdate_Data::SetTrackingItemUpdate(const FPragma_Inventory_TrackingItemUpdate& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtInstancedItemServerUpdate_DataType::TrackingItemUpdate;
	new(Union.TrackingItemUpdate.GetTypedPtr()) FPragma_Inventory_TrackingItemUpdate(Value);
}

bool FPragma_Inventory_ExtInstancedItemServerUpdate_Data::SerializeIntoParentJson(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	const FPragma_Inventory_ExtInstancedItemServerUpdate_Data& OneOf = static_cast<const FPragma_Inventory_ExtInstancedItemServerUpdate*>(Value)->Data;
	switch (OneOf.OneOfType())
	{
		case EPragma_Inventory_ExtInstancedItemServerUpdate_DataType::ActiveMissionsUpdate:
			OutJsonObj->SetField("activeMissionsUpdate", PragmaJson::StructToJsonValue(*OneOf.Union.ActiveMissionsUpdate.GetTypedPtr()));
			break;
		case EPragma_Inventory_ExtInstancedItemServerUpdate_DataType::PetUpdate:
			OutJsonObj->SetField("petUpdate", PragmaJson::StructToJsonValue(*OneOf.Union.PetUpdate.GetTypedPtr()));
			break;
		case EPragma_Inventory_ExtInstancedItemServerUpdate_DataType::TrackingItemUpdate:
			OutJsonObj->SetField("trackingItemUpdate", PragmaJson::StructToJsonValue(*OneOf.Union.TrackingItemUpdate.GetTypedPtr()));
			break;
		default:
			break;
	}
	// Per protobuf spec, it's ok to have empty oneof.
	return true;
}
bool FPragma_Inventory_ExtInstancedItemServerUpdate_Data::DeserializeFromParentJson(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	FPragma_Inventory_ExtInstancedItemServerUpdate_Data& OutOneOf = static_cast<FPragma_Inventory_ExtInstancedItemServerUpdate*>(OutValue)->Data;
	if (JsonObj->HasField("activeMissionsUpdate"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtInstancedItemServerUpdate_DataType::ActiveMissionsUpdate;
		new(OutOneOf.Union.ActiveMissionsUpdate.GetTypedPtr()) FPragma_Ext_ActiveMissionsUpdate(PragmaJson::JsonValueToStruct<FPragma_Ext_ActiveMissionsUpdate>(JsonObj->TryGetField(TEXT("activeMissionsUpdate")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	if (JsonObj->HasField("petUpdate"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtInstancedItemServerUpdate_DataType::PetUpdate;
		new(OutOneOf.Union.PetUpdate.GetTypedPtr()) FPragma_Inventory_PetUpdate(PragmaJson::JsonValueToStruct<FPragma_Inventory_PetUpdate>(JsonObj->TryGetField(TEXT("petUpdate")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	if (JsonObj->HasField("trackingItemUpdate"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtInstancedItemServerUpdate_DataType::TrackingItemUpdate;
		new(OutOneOf.Union.TrackingItemUpdate.GetTypedPtr()) FPragma_Inventory_TrackingItemUpdate(PragmaJson::JsonValueToStruct<FPragma_Inventory_TrackingItemUpdate>(JsonObj->TryGetField(TEXT("trackingItemUpdate")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	// Per protobuf spec, oneofs have _at most_ one of the fields. None set is valid, so we always return true.
	return true;
}

bool operator==(const FPragma_Inventory_ExtInstancedItemServerUpdate_Data& Lhs, const FPragma_Inventory_ExtInstancedItemServerUpdate_Data& Rhs)
{
	return Lhs.Equals(Rhs);
}
bool operator!=(const FPragma_Inventory_ExtInstancedItemServerUpdate_Data& Lhs, const FPragma_Inventory_ExtInstancedItemServerUpdate_Data& Rhs)
{
	return !(Lhs == Rhs);
}


bool FPragma_Inventory_ExtInstancedItemServerUpdate::AddonSerializer(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	bool Success = true;
	Success &= FPragma_Inventory_ExtInstancedItemServerUpdate_Data::SerializeIntoParentJson(Value, OutJsonObj);
	return Success;
}

bool FPragma_Inventory_ExtInstancedItemServerUpdate::AddonDeserializer(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	bool Success = true;
	Success &= FPragma_Inventory_ExtInstancedItemServerUpdate_Data::DeserializeFromParentJson(JsonObj, OutValue);
	return Success;
}

bool operator==(const FPragma_Inventory_ExtInstancedItemServerUpdate& Lhs, const FPragma_Inventory_ExtInstancedItemServerUpdate& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.Data == Rhs.Data
;
}
bool operator!=(const FPragma_Inventory_ExtInstancedItemServerUpdate& Lhs, const FPragma_Inventory_ExtInstancedItemServerUpdate& Rhs)
{
	return !(Lhs == Rhs);
}

FPragma_Inventory_ExtInstancedItemUpdate_Data::FPragma_Inventory_ExtInstancedItemUpdate_Data() {}
FPragma_Inventory_ExtInstancedItemUpdate_Data::~FPragma_Inventory_ExtInstancedItemUpdate_Data()
{
	Reset();
}

FPragma_Inventory_ExtInstancedItemUpdate_Data::FPragma_Inventory_ExtInstancedItemUpdate_Data(const FPragma_Inventory_ExtInstancedItemUpdate_Data& Other)
{
	*this = Other;
}

bool FPragma_Inventory_ExtInstancedItemUpdate_Data::Equals(const FPragma_Inventory_ExtInstancedItemUpdate_Data& Other) const
{
    if (OneOfType() != Other.OneOfType())
    {
        return false;
    }
	switch (OneOfType())
	{
	case EPragma_Inventory_ExtInstancedItemUpdate_DataType::PetUpdate:
		return PetUpdate() == Other.PetUpdate();
	case EPragma_Inventory_ExtInstancedItemUpdate_DataType::Invalid:
        return true;
	default:
		return false;
	}
}

FPragma_Inventory_ExtInstancedItemUpdate_Data& FPragma_Inventory_ExtInstancedItemUpdate_Data::operator=(const FPragma_Inventory_ExtInstancedItemUpdate_Data& Other)
{
	Reset();
	Type = Other.OneOfType();
	switch (Other.OneOfType())
	{
	case EPragma_Inventory_ExtInstancedItemUpdate_DataType::PetUpdate:
		new(Union.PetUpdate.GetTypedPtr()) FPragma_Inventory_PetUpdate(Other.PetUpdate());
		break;
	case EPragma_Inventory_ExtInstancedItemUpdate_DataType::Invalid:
	default:
		break;
	}
	return *this;
}

void FPragma_Inventory_ExtInstancedItemUpdate_Data::Reset()
{
	switch (OneOfType())
	{
	case EPragma_Inventory_ExtInstancedItemUpdate_DataType::PetUpdate:
		Union.PetUpdate.GetTypedPtr()->~FPragma_Inventory_PetUpdate();
		break;
	case EPragma_Inventory_ExtInstancedItemUpdate_DataType::Invalid:
	default:
		break;
	}
	Type = EPragma_Inventory_ExtInstancedItemUpdate_DataType::Invalid;
}

const FPragma_Inventory_PetUpdate& FPragma_Inventory_ExtInstancedItemUpdate_Data::PetUpdate() const {
	checkf(OneOfType() == EPragma_Inventory_ExtInstancedItemUpdate_DataType::PetUpdate, TEXT("Failed to retrieve PetUpdate from FPragma_Inventory_ExtInstancedItemUpdate_Data. Check the OneOfType() before accessing the value."));
	return *Union.PetUpdate.GetTypedPtr();
}

void FPragma_Inventory_ExtInstancedItemUpdate_Data::SetPetUpdate(const FPragma_Inventory_PetUpdate& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtInstancedItemUpdate_DataType::PetUpdate;
	new(Union.PetUpdate.GetTypedPtr()) FPragma_Inventory_PetUpdate(Value);
}

bool FPragma_Inventory_ExtInstancedItemUpdate_Data::SerializeIntoParentJson(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	const FPragma_Inventory_ExtInstancedItemUpdate_Data& OneOf = static_cast<const FPragma_Inventory_ExtInstancedItemUpdate*>(Value)->Data;
	switch (OneOf.OneOfType())
	{
		case EPragma_Inventory_ExtInstancedItemUpdate_DataType::PetUpdate:
			OutJsonObj->SetField("petUpdate", PragmaJson::StructToJsonValue(*OneOf.Union.PetUpdate.GetTypedPtr()));
			break;
		default:
			break;
	}
	// Per protobuf spec, it's ok to have empty oneof.
	return true;
}
bool FPragma_Inventory_ExtInstancedItemUpdate_Data::DeserializeFromParentJson(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	FPragma_Inventory_ExtInstancedItemUpdate_Data& OutOneOf = static_cast<FPragma_Inventory_ExtInstancedItemUpdate*>(OutValue)->Data;
	if (JsonObj->HasField("petUpdate"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtInstancedItemUpdate_DataType::PetUpdate;
		new(OutOneOf.Union.PetUpdate.GetTypedPtr()) FPragma_Inventory_PetUpdate(PragmaJson::JsonValueToStruct<FPragma_Inventory_PetUpdate>(JsonObj->TryGetField(TEXT("petUpdate")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	// Per protobuf spec, oneofs have _at most_ one of the fields. None set is valid, so we always return true.
	return true;
}

bool operator==(const FPragma_Inventory_ExtInstancedItemUpdate_Data& Lhs, const FPragma_Inventory_ExtInstancedItemUpdate_Data& Rhs)
{
	return Lhs.Equals(Rhs);
}
bool operator!=(const FPragma_Inventory_ExtInstancedItemUpdate_Data& Lhs, const FPragma_Inventory_ExtInstancedItemUpdate_Data& Rhs)
{
	return !(Lhs == Rhs);
}


bool FPragma_Inventory_ExtInstancedItemUpdate::AddonSerializer(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	bool Success = true;
	Success &= FPragma_Inventory_ExtInstancedItemUpdate_Data::SerializeIntoParentJson(Value, OutJsonObj);
	return Success;
}

bool FPragma_Inventory_ExtInstancedItemUpdate::AddonDeserializer(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	bool Success = true;
	Success &= FPragma_Inventory_ExtInstancedItemUpdate_Data::DeserializeFromParentJson(JsonObj, OutValue);
	return Success;
}

bool operator==(const FPragma_Inventory_ExtInstancedItemUpdate& Lhs, const FPragma_Inventory_ExtInstancedItemUpdate& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.Reserved == Rhs.Reserved
			&& Lhs.Tags == Rhs.Tags
			&& Lhs.Data == Rhs.Data
;
}
bool operator!=(const FPragma_Inventory_ExtInstancedItemUpdate& Lhs, const FPragma_Inventory_ExtInstancedItemUpdate& Rhs)
{
	return !(Lhs == Rhs);
}


bool operator==(const FPragma_Inventory_PetEvolution& Lhs, const FPragma_Inventory_PetEvolution& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.Pet == Rhs.Pet
;
}
bool operator!=(const FPragma_Inventory_PetEvolution& Lhs, const FPragma_Inventory_PetEvolution& Rhs)
{
	return !(Lhs == Rhs);
}

FPragma_Inventory_ExtInstancedItemServerGrant_Data::FPragma_Inventory_ExtInstancedItemServerGrant_Data() {}
FPragma_Inventory_ExtInstancedItemServerGrant_Data::~FPragma_Inventory_ExtInstancedItemServerGrant_Data()
{
	Reset();
}

FPragma_Inventory_ExtInstancedItemServerGrant_Data::FPragma_Inventory_ExtInstancedItemServerGrant_Data(const FPragma_Inventory_ExtInstancedItemServerGrant_Data& Other)
{
	*this = Other;
}

bool FPragma_Inventory_ExtInstancedItemServerGrant_Data::Equals(const FPragma_Inventory_ExtInstancedItemServerGrant_Data& Other) const
{
    if (OneOfType() != Other.OneOfType())
    {
        return false;
    }
	switch (OneOfType())
	{
	case EPragma_Inventory_ExtInstancedItemServerGrant_DataType::PetEvolution:
		return PetEvolution() == Other.PetEvolution();
	case EPragma_Inventory_ExtInstancedItemServerGrant_DataType::IncompleteFood:
		return IncompleteFood() == Other.IncompleteFood();
	case EPragma_Inventory_ExtInstancedItemServerGrant_DataType::Invalid:
        return true;
	default:
		return false;
	}
}

FPragma_Inventory_ExtInstancedItemServerGrant_Data& FPragma_Inventory_ExtInstancedItemServerGrant_Data::operator=(const FPragma_Inventory_ExtInstancedItemServerGrant_Data& Other)
{
	Reset();
	Type = Other.OneOfType();
	switch (Other.OneOfType())
	{
	case EPragma_Inventory_ExtInstancedItemServerGrant_DataType::PetEvolution:
		new(Union.PetEvolution.GetTypedPtr()) FPragma_Inventory_PetEvolution(Other.PetEvolution());
		break;
	case EPragma_Inventory_ExtInstancedItemServerGrant_DataType::IncompleteFood:
		new(Union.IncompleteFood.GetTypedPtr()) FPragma_Inventory_IncompleteFood(Other.IncompleteFood());
		break;
	case EPragma_Inventory_ExtInstancedItemServerGrant_DataType::Invalid:
	default:
		break;
	}
	return *this;
}

void FPragma_Inventory_ExtInstancedItemServerGrant_Data::Reset()
{
	switch (OneOfType())
	{
	case EPragma_Inventory_ExtInstancedItemServerGrant_DataType::PetEvolution:
		Union.PetEvolution.GetTypedPtr()->~FPragma_Inventory_PetEvolution();
		break;
	case EPragma_Inventory_ExtInstancedItemServerGrant_DataType::IncompleteFood:
		Union.IncompleteFood.GetTypedPtr()->~FPragma_Inventory_IncompleteFood();
		break;
	case EPragma_Inventory_ExtInstancedItemServerGrant_DataType::Invalid:
	default:
		break;
	}
	Type = EPragma_Inventory_ExtInstancedItemServerGrant_DataType::Invalid;
}

const FPragma_Inventory_PetEvolution& FPragma_Inventory_ExtInstancedItemServerGrant_Data::PetEvolution() const {
	checkf(OneOfType() == EPragma_Inventory_ExtInstancedItemServerGrant_DataType::PetEvolution, TEXT("Failed to retrieve PetEvolution from FPragma_Inventory_ExtInstancedItemServerGrant_Data. Check the OneOfType() before accessing the value."));
	return *Union.PetEvolution.GetTypedPtr();
}
const FPragma_Inventory_IncompleteFood& FPragma_Inventory_ExtInstancedItemServerGrant_Data::IncompleteFood() const {
	checkf(OneOfType() == EPragma_Inventory_ExtInstancedItemServerGrant_DataType::IncompleteFood, TEXT("Failed to retrieve IncompleteFood from FPragma_Inventory_ExtInstancedItemServerGrant_Data. Check the OneOfType() before accessing the value."));
	return *Union.IncompleteFood.GetTypedPtr();
}

void FPragma_Inventory_ExtInstancedItemServerGrant_Data::SetPetEvolution(const FPragma_Inventory_PetEvolution& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtInstancedItemServerGrant_DataType::PetEvolution;
	new(Union.PetEvolution.GetTypedPtr()) FPragma_Inventory_PetEvolution(Value);
}
void FPragma_Inventory_ExtInstancedItemServerGrant_Data::SetIncompleteFood(const FPragma_Inventory_IncompleteFood& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtInstancedItemServerGrant_DataType::IncompleteFood;
	new(Union.IncompleteFood.GetTypedPtr()) FPragma_Inventory_IncompleteFood(Value);
}

bool FPragma_Inventory_ExtInstancedItemServerGrant_Data::SerializeIntoParentJson(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	const FPragma_Inventory_ExtInstancedItemServerGrant_Data& OneOf = static_cast<const FPragma_Inventory_ExtInstancedItemServerGrant*>(Value)->Data;
	switch (OneOf.OneOfType())
	{
		case EPragma_Inventory_ExtInstancedItemServerGrant_DataType::PetEvolution:
			OutJsonObj->SetField("petEvolution", PragmaJson::StructToJsonValue(*OneOf.Union.PetEvolution.GetTypedPtr()));
			break;
		case EPragma_Inventory_ExtInstancedItemServerGrant_DataType::IncompleteFood:
			OutJsonObj->SetField("incompleteFood", PragmaJson::StructToJsonValue(*OneOf.Union.IncompleteFood.GetTypedPtr()));
			break;
		default:
			break;
	}
	// Per protobuf spec, it's ok to have empty oneof.
	return true;
}
bool FPragma_Inventory_ExtInstancedItemServerGrant_Data::DeserializeFromParentJson(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	FPragma_Inventory_ExtInstancedItemServerGrant_Data& OutOneOf = static_cast<FPragma_Inventory_ExtInstancedItemServerGrant*>(OutValue)->Data;
	if (JsonObj->HasField("petEvolution"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtInstancedItemServerGrant_DataType::PetEvolution;
		new(OutOneOf.Union.PetEvolution.GetTypedPtr()) FPragma_Inventory_PetEvolution(PragmaJson::JsonValueToStruct<FPragma_Inventory_PetEvolution>(JsonObj->TryGetField(TEXT("petEvolution")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	if (JsonObj->HasField("incompleteFood"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtInstancedItemServerGrant_DataType::IncompleteFood;
		new(OutOneOf.Union.IncompleteFood.GetTypedPtr()) FPragma_Inventory_IncompleteFood(PragmaJson::JsonValueToStruct<FPragma_Inventory_IncompleteFood>(JsonObj->TryGetField(TEXT("incompleteFood")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	// Per protobuf spec, oneofs have _at most_ one of the fields. None set is valid, so we always return true.
	return true;
}

bool operator==(const FPragma_Inventory_ExtInstancedItemServerGrant_Data& Lhs, const FPragma_Inventory_ExtInstancedItemServerGrant_Data& Rhs)
{
	return Lhs.Equals(Rhs);
}
bool operator!=(const FPragma_Inventory_ExtInstancedItemServerGrant_Data& Lhs, const FPragma_Inventory_ExtInstancedItemServerGrant_Data& Rhs)
{
	return !(Lhs == Rhs);
}


bool FPragma_Inventory_ExtInstancedItemServerGrant::AddonSerializer(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	bool Success = true;
	Success &= FPragma_Inventory_ExtInstancedItemServerGrant_Data::SerializeIntoParentJson(Value, OutJsonObj);
	return Success;
}

bool FPragma_Inventory_ExtInstancedItemServerGrant::AddonDeserializer(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	bool Success = true;
	Success &= FPragma_Inventory_ExtInstancedItemServerGrant_Data::DeserializeFromParentJson(JsonObj, OutValue);
	return Success;
}

bool operator==(const FPragma_Inventory_ExtInstancedItemServerGrant& Lhs, const FPragma_Inventory_ExtInstancedItemServerGrant& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.Data == Rhs.Data
;
}
bool operator!=(const FPragma_Inventory_ExtInstancedItemServerGrant& Lhs, const FPragma_Inventory_ExtInstancedItemServerGrant& Rhs)
{
	return !(Lhs == Rhs);
}

FPragma_Inventory_ExtPurchaseRequest_Data::FPragma_Inventory_ExtPurchaseRequest_Data() {}
FPragma_Inventory_ExtPurchaseRequest_Data::~FPragma_Inventory_ExtPurchaseRequest_Data()
{
	Reset();
}

FPragma_Inventory_ExtPurchaseRequest_Data::FPragma_Inventory_ExtPurchaseRequest_Data(const FPragma_Inventory_ExtPurchaseRequest_Data& Other)
{
	*this = Other;
}

bool FPragma_Inventory_ExtPurchaseRequest_Data::Equals(const FPragma_Inventory_ExtPurchaseRequest_Data& Other) const
{
    if (OneOfType() != Other.OneOfType())
    {
        return false;
    }
	switch (OneOfType())
	{
	case EPragma_Inventory_ExtPurchaseRequest_DataType::PetBonus:
		return PetBonus() == Other.PetBonus();
	case EPragma_Inventory_ExtPurchaseRequest_DataType::Invalid:
        return true;
	default:
		return false;
	}
}

FPragma_Inventory_ExtPurchaseRequest_Data& FPragma_Inventory_ExtPurchaseRequest_Data::operator=(const FPragma_Inventory_ExtPurchaseRequest_Data& Other)
{
	Reset();
	Type = Other.OneOfType();
	switch (Other.OneOfType())
	{
	case EPragma_Inventory_ExtPurchaseRequest_DataType::PetBonus:
		new(Union.PetBonus.GetTypedPtr()) EPragma_Inventory_PetBonus(Other.PetBonus());
		break;
	case EPragma_Inventory_ExtPurchaseRequest_DataType::Invalid:
	default:
		break;
	}
	return *this;
}

void FPragma_Inventory_ExtPurchaseRequest_Data::Reset()
{
	switch (OneOfType())
	{
	case EPragma_Inventory_ExtPurchaseRequest_DataType::PetBonus:
		// Primitive type, no destructor.
		break;
	case EPragma_Inventory_ExtPurchaseRequest_DataType::Invalid:
	default:
		break;
	}
	Type = EPragma_Inventory_ExtPurchaseRequest_DataType::Invalid;
}

const EPragma_Inventory_PetBonus& FPragma_Inventory_ExtPurchaseRequest_Data::PetBonus() const {
	checkf(OneOfType() == EPragma_Inventory_ExtPurchaseRequest_DataType::PetBonus, TEXT("Failed to retrieve PetBonus from FPragma_Inventory_ExtPurchaseRequest_Data. Check the OneOfType() before accessing the value."));
	return *Union.PetBonus.GetTypedPtr();
}

void FPragma_Inventory_ExtPurchaseRequest_Data::SetPetBonus(const EPragma_Inventory_PetBonus& Value)
{
	Reset();
	Type = EPragma_Inventory_ExtPurchaseRequest_DataType::PetBonus;
	new(Union.PetBonus.GetTypedPtr()) EPragma_Inventory_PetBonus(Value);
}

bool FPragma_Inventory_ExtPurchaseRequest_Data::SerializeIntoParentJson(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	const FPragma_Inventory_ExtPurchaseRequest_Data& OneOf = static_cast<const FPragma_Inventory_ExtPurchaseRequest*>(Value)->Data;
	switch (OneOf.OneOfType())
	{
		case EPragma_Inventory_ExtPurchaseRequest_DataType::PetBonus:
			OutJsonObj->SetField("petBonus", PragmaJson::EnumToJsonValue(*OneOf.Union.PetBonus.GetTypedPtr()));
			break;
		default:
			break;
	}
	// Per protobuf spec, it's ok to have empty oneof.
	return true;
}
bool FPragma_Inventory_ExtPurchaseRequest_Data::DeserializeFromParentJson(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	FPragma_Inventory_ExtPurchaseRequest_Data& OutOneOf = static_cast<FPragma_Inventory_ExtPurchaseRequest*>(OutValue)->Data;
	if (JsonObj->HasField("petBonus"))
	{
		OutOneOf.Type = EPragma_Inventory_ExtPurchaseRequest_DataType::PetBonus;
		new(OutOneOf.Union.PetBonus.GetTypedPtr()) EPragma_Inventory_PetBonus(PragmaJson::JsonValueToEnum<EPragma_Inventory_PetBonus>(JsonObj->TryGetField(TEXT("petBonus")).ToSharedRef()));
		return true; // return to short circuit any other checks.
	}
	// Per protobuf spec, oneofs have _at most_ one of the fields. None set is valid, so we always return true.
	return true;
}

bool operator==(const FPragma_Inventory_ExtPurchaseRequest_Data& Lhs, const FPragma_Inventory_ExtPurchaseRequest_Data& Rhs)
{
	return Lhs.Equals(Rhs);
}
bool operator!=(const FPragma_Inventory_ExtPurchaseRequest_Data& Lhs, const FPragma_Inventory_ExtPurchaseRequest_Data& Rhs)
{
	return !(Lhs == Rhs);
}


bool FPragma_Inventory_ExtPurchaseRequest::AddonSerializer(const void* Value, TSharedRef<FJsonObject>& OutJsonObj)
{
	bool Success = true;
	Success &= FPragma_Inventory_ExtPurchaseRequest_Data::SerializeIntoParentJson(Value, OutJsonObj);
	return Success;
}

bool FPragma_Inventory_ExtPurchaseRequest::AddonDeserializer(const TSharedRef<FJsonObject>& JsonObj, void* OutValue)
{
	bool Success = true;
	Success &= FPragma_Inventory_ExtPurchaseRequest_Data::DeserializeFromParentJson(JsonObj, OutValue);
	return Success;
}

bool operator==(const FPragma_Inventory_ExtPurchaseRequest& Lhs, const FPragma_Inventory_ExtPurchaseRequest& Rhs)
{
	return true // Initial true allows simpler codegen.
			&& Lhs.Data == Rhs.Data
;
}
bool operator!=(const FPragma_Inventory_ExtPurchaseRequest& Lhs, const FPragma_Inventory_ExtPurchaseRequest& Rhs)
{
	return !(Lhs == Rhs);
}
